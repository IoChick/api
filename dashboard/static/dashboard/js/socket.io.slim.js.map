{
version: 3,
sources: [
"webpack:///webpack/universalModuleDefinition",
"webpack:///socket.io.slim.js",
"webpack:///webpack/bootstrap 82d2f1547c0a2d88046d",
"webpack:///./lib/index.js",
"webpack:///./lib/url.js",
"webpack:///./~/parseuri/index.js",
"webpack:///./support/noop.js",
"webpack:///./~/socket.io-parser/index.js",
"webpack:///./~/component-emitter/index.js",
"webpack:///./~/socket.io-parser/binary.js",
"webpack:///./~/isarray/index.js",
"webpack:///./~/socket.io-parser/is-buffer.js",
"webpack:///./lib/manager.js",
"webpack:///./~/engine.io-client/lib/index.js",
"webpack:///./~/engine.io-client/lib/socket.js",
"webpack:///./~/engine.io-client/lib/transports/index.js",
"webpack:///./~/engine.io-client/lib/xmlhttprequest.js",
"webpack:///./~/has-cors/index.js",
"webpack:///./~/engine.io-client/lib/transports/polling-xhr.js",
"webpack:///./~/engine.io-client/lib/transports/polling.js",
"webpack:///./~/engine.io-client/lib/transport.js",
"webpack:///./~/engine.io-parser/lib/browser.js",
"webpack:///./~/engine.io-parser/lib/keys.js",
"webpack:///./~/has-binary2/index.js",
"webpack:///./~/arraybuffer.slice/index.js",
"webpack:///./~/after/index.js",
"webpack:///./~/engine.io-parser/lib/utf8.js",
"webpack:///(webpack)/buildin/module.js",
"webpack:///./~/base64-arraybuffer/lib/base64-arraybuffer.js",
"webpack:///./~/blob/index.js",
"webpack:///./~/parseqs/index.js",
"webpack:///./~/component-inherit/index.js",
"webpack:///./~/yeast/index.js",
"webpack:///./~/engine.io-client/lib/transports/polling-jsonp.js",
"webpack:///./~/engine.io-client/lib/transports/websocket.js",
"webpack:///./~/indexof/index.js",
"webpack:///./lib/socket.js",
"webpack:///./~/to-array/index.js",
"webpack:///./lib/on.js",
"webpack:///./~/component-bind/index.js",
"webpack:///./~/backo2/index.js"
],
names: [
"root",
"factory",
"exports",
"module",
"define",
"amd",
"this",
"modules",
"__webpack_require__",
"moduleId",
"installedModules",
"id",
"loaded",
"call",
"m",
"c",
"p",
"lookup",
"uri",
"opts",
"_typeof",
"undefined",
"io",
"parsed",
"url",
"source",
"path",
"sameNamespace",
"cache",
"nsps",
"newConnection",
"forceNew",
"multiplex",
"Manager",
"query",
"socket",
"Symbol",
"iterator",
"obj",
"constructor",
"prototype",
"parser",
"managers",
"protocol",
"connect",
"Socket",
"global",
"loc",
"location",
"host",
"charAt",
"test",
"parseuri",
"port",
"ipv6",
"indexOf",
"href",
"re",
"parts",
"str",
"src",
"b",
"e",
"substring",
"replace",
"length",
"exec",
"i",
"authority",
"ipv6uri",
"Encoder",
"encodeAsString",
"type",
"BINARY_EVENT",
"BINARY_ACK",
"attachments",
"nsp",
"data",
"payload",
"tryStringify",
"ERROR_PACKET",
"JSON",
"stringify",
"encodeAsBinary",
"callback",
"writeEncoding",
"bloblessData",
"deconstruction",
"binary",
"deconstructPacket",
"pack",
"packet",
"buffers",
"unshift",
"removeBlobs",
"Decoder",
"reconstructor",
"decodeString",
"Number",
"types",
"error",
"buf",
"Error",
"next",
"tryParse",
"substr",
"isPayloadValid",
"ERROR",
"isArray",
"parse",
"BinaryReconstructor",
"reconPack",
"msg",
"Emitter",
"isBuf",
"CONNECT",
"DISCONNECT",
"EVENT",
"ACK",
"encode",
"encoding",
"add",
"emit",
"base64",
"takeBinaryData",
"destroy",
"finishedReconstruction",
"binData",
"push",
"reconstructPacket",
"mixin",
"key",
"on",
"addEventListener",
"event",
"fn",
"_callbacks",
"once",
"off",
"apply",
"arguments",
"removeListener",
"removeAllListeners",
"removeEventListener",
"callbacks",
"cb",
"splice",
"args",
"slice",
"len",
"listeners",
"hasListeners",
"_deconstructPacket",
"placeholder",
"_placeholder",
"num",
"newData",
"Array",
"Date",
"_reconstructPacket",
"toString",
"Object",
"withNativeBlob",
"Blob",
"withNativeFile",
"File",
"packetData",
"_removeBlobs",
"curKey",
"containingObject",
"pendingBlobs",
"fileReader",
"FileReader",
"onload",
"result",
"readAsArrayBuffer",
"arr",
"withNativeBuffer",
"Buffer",
"isBuffer",
"withNativeArrayBuffer",
"ArrayBuffer",
"isView",
"buffer",
"subs",
"reconnection",
"reconnectionAttempts",
"Infinity",
"reconnectionDelay",
"reconnectionDelayMax",
"randomizationFactor",
"backoff",
"Backoff",
"min",
"max",
"jitter",
"timeout",
"readyState",
"connecting",
"lastPing",
"packetBuffer",
"_parser",
"encoder",
"decoder",
"autoConnect",
"open",
"eio",
"bind",
"has",
"hasOwnProperty",
"emitAll",
"updateSocketIds",
"generateId",
"engine",
"v",
"_reconnection",
"_reconnectionAttempts",
"_reconnectionDelay",
"setMin",
"_randomizationFactor",
"setJitter",
"_reconnectionDelayMax",
"setMax",
"_timeout",
"maybeReconnectOnOpen",
"reconnecting",
"attempts",
"reconnect",
"self",
"skipReconnect",
"openSub",
"onopen",
"errorSub",
"cleanup",
"err",
"timer",
"setTimeout",
"close",
"clearTimeout",
"onping",
"onpong",
"ondata",
"ondecoded",
"onerror",
"onConnecting",
"index",
"encodedPackets",
"write",
"options",
"processPacketQueue",
"shift",
"subsLength",
"sub",
"disconnect",
"reset",
"onclose",
"reason",
"delay",
"duration",
"onreconnect",
"attempt",
"hostname",
"secure",
"agent",
"parseqs",
"decode",
"upgrade",
"forceJSONP",
"jsonp",
"forceBase64",
"enablesXDR",
"timestampParam",
"timestampRequests",
"transports",
"transportOptions",
"writeBuffer",
"prevBufferLen",
"policyPort",
"rememberUpgrade",
"binaryType",
"onlyBinaryUpgrades",
"perMessageDeflate",
"threshold",
"pfx",
"passphrase",
"cert",
"ca",
"ciphers",
"rejectUnauthorized",
"forceNode",
"freeGlobal",
"extraHeaders",
"keys",
"localAddress",
"upgrades",
"pingInterval",
"pingTimeout",
"pingIntervalTimer",
"pingTimeoutTimer",
"clone",
"o",
"priorWebsocketSuccess",
"Transport",
"createTransport",
"name",
"EIO",
"transport",
"sid",
"requestTimeout",
"protocols",
"setTransport",
"onDrain",
"onPacket",
"onError",
"onClose",
"probe",
"onTransportOpen",
"upgradeLosesBinary",
"supportsBinary",
"failed",
"send",
"upgrading",
"pause",
"flush",
"freezeTransport",
"onTransportClose",
"onupgrade",
"to",
"onOpen",
"l",
"onHandshake",
"setPing",
"code",
"filterUpgrades",
"onHeartbeat",
"ping",
"sendPacket",
"writable",
"compress",
"cleanupAndClose",
"waitForUpgrade",
"desc",
"filteredUpgrades",
"j",
"polling",
"xhr",
"xd",
"xs",
"isSSL",
"xdomain",
"xscheme",
"XMLHttpRequest",
"XHR",
"JSONP",
"websocket",
"hasCORS",
"XDomainRequest",
"concat",
"join",
"empty",
"Polling",
"Request",
"method",
"async",
"isBinary",
"create",
"unloadHandler",
"requests",
"abort",
"inherit",
"request",
"doWrite",
"req",
"sendXhr",
"doPoll",
"onData",
"pollXhr",
"setDisableHeaderCheck",
"setRequestHeader",
"withCredentials",
"hasXDR",
"onLoad",
"responseText",
"onreadystatechange",
"contentType",
"getResponseHeader",
"responseType",
"status",
"document",
"requestsCount",
"onSuccess",
"fromError",
"response",
"attachEvent",
"hasXHR2",
"yeast",
"doOpen",
"poll",
"onPause",
"total",
"decodePayload",
"doClose",
"packets",
"callbackfn",
"encodePayload",
"schema",
"b64",
"description",
"decodePacket",
"encodeBase64Object",
"message",
"encodeArrayBuffer",
"encodeBase64Packet",
"contentArray",
"Uint8Array",
"resultBuffer",
"byteLength",
"encodeBlobAsArrayBuffer",
"fr",
"encodePacket",
"encodeBlob",
"dontSendBlobs",
"blob",
"tryDecode",
"utf8",
"strict",
"map",
"ary",
"each",
"done",
"after",
"eachWithIndex",
"el",
"base64encoder",
"hasBinary",
"sliceBuffer",
"isAndroid",
"navigator",
"userAgent",
"isPhantomJS",
"pong",
"noop",
"packetslist",
"utf8encode",
"encoded",
"String",
"split",
"readAsDataURL",
"b64data",
"fromCharCode",
"typed",
"basic",
"btoa",
"utf8decode",
"decodeBase64Packet",
"asArray",
"rest",
"setLengthHeader",
"encodeOne",
"doneCallback",
"encodePayloadAsBlob",
"encodePayloadAsArrayBuffer",
"results",
"decodePayloadAsBinary",
"n",
"chr",
"ret",
"totalLength",
"reduce",
"acc",
"resultArray",
"bufferIndex",
"forEach",
"isString",
"ab",
"view",
"charCodeAt",
"lenStr",
"parseInt",
"binaryIdentifier",
"size",
"lengthAry",
"bufferTail",
"tailArray",
"msgLength",
"toJSON",
"arraybuffer",
"start",
"end",
"bytes",
"abv",
"ii",
"count",
"err_cb",
"proxy",
"bail",
"__WEBPACK_AMD_DEFINE_RESULT__",
"ucs2decode",
"string",
"value",
"extra",
"output",
"counter",
"ucs2encode",
"array",
"stringFromCharCode",
"checkScalarValue",
"codePoint",
"toUpperCase",
"createByte",
"encodeCodePoint",
"symbol",
"codePoints",
"byteString",
"readContinuationByte",
"byteIndex",
"byteCount",
"continuationByte",
"byteArray",
"decodeSymbol",
"byte1",
"byte2",
"byte3",
"byte4",
"tmp",
"freeExports",
"window",
"version",
"webpackPolyfill",
"deprecate",
"paths",
"children",
"chars",
"encoded1",
"encoded2",
"encoded3",
"encoded4",
"bufferLength",
"mapArrayBufferViews",
"chunk",
"copy",
"set",
"byteOffset",
"BlobBuilderConstructor",
"bb",
"BlobBuilder",
"append",
"getBlob",
"BlobConstructor",
"WebKitBlobBuilder",
"MSBlobBuilder",
"MozBlobBuilder",
"blobSupported",
"a",
"blobSupportsArrayBufferView",
"blobBuilderSupported",
"encodeURIComponent",
"qs",
"qry",
"pairs",
"pair",
"decodeURIComponent",
"alphabet",
"Math",
"floor",
"decoded",
"now",
"prev",
"seed",
"JSONPPolling",
"___eio",
"script",
"rNewline",
"rEscapedNewline",
"parentNode",
"removeChild",
"form",
"iframe",
"createElement",
"insertAt",
"getElementsByTagName",
"insertBefore",
"head",
"body",
"appendChild",
"isUAgecko",
"complete",
"initIframe",
"html",
"iframeId",
"area",
"className",
"style",
"position",
"top",
"left",
"target",
"setAttribute",
"action",
"submit",
"WS",
"usingBrowserWebSocket",
"BrowserWebSocket",
"WebSocket",
"NodeWebSocket",
"MozWebSocket",
"check",
"headers",
"ws",
"supports",
"addEventListeners",
"onmessage",
"ev",
"json",
"ids",
"acks",
"receiveBuffer",
"sendBuffer",
"connected",
"disconnected",
"flags",
"toArray",
"hasBin",
"events",
"connect_error",
"connect_timeout",
"reconnect_attempt",
"reconnect_failed",
"reconnect_error",
"subEvents",
"pop",
"onpacket",
"rootNamespaceError",
"onconnect",
"onevent",
"onack",
"ondisconnect",
"ack",
"sent",
"emitBuffered",
"list",
"ms",
"factor",
"pow",
"rand",
"random",
"deviation"
],
mappings: "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",
file: "socket.io.slim.js",
sourcesContent: [
"(function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' && define.amd) define([], factory); else if(typeof exports === 'object') exports["io"] = factory(); else root["io"] = factory(); })(this, function() { return // WEBPACK FOOTER // // webpack/universalModuleDefinition",
"(function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' && define.amd) define([], factory); else if(typeof exports === 'object') exports["io"] = factory(); else root["io"] = factory(); })(this, function() { return /******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if(installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = ""; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /** * Module dependencies. */ var url = __webpack_require__(1); var parser = __webpack_require__(4); var Manager = __webpack_require__(9); var debug = __webpack_require__(3)('socket.io-client'); /** * Module exports. */ module.exports = exports = lookup; /** * Managers cache. */ var cache = exports.managers = {}; /** * Looks up an existing `Manager` for multiplexing. * If the user summons: * * `io('http://localhost/a');` * `io('http://localhost/b');` * * We reuse the existing instance based on same scheme/port/host, * and we initialize sockets for each namespace. * * @api public */ function lookup(uri, opts) { if ((typeof uri === 'undefined' ? 'undefined' : _typeof(uri)) === 'object') { opts = uri; uri = undefined; } opts = opts || {}; var parsed = url(uri); var source = parsed.source; var id = parsed.id; var path = parsed.path; var sameNamespace = cache[id] && path in cache[id].nsps; var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace; var io; if (newConnection) { io = Manager(source, opts); } else { if (!cache[id]) { cache[id] = Manager(source, opts); } io = cache[id]; } if (parsed.query && !opts.query) { opts.query = parsed.query; } return io.socket(parsed.path, opts); } /** * Protocol version. * * @api public */ exports.protocol = parser.protocol; /** * `connect`. * * @param {String} uri * @api public */ exports.connect = lookup; /** * Expose constructors for standalone build. * * @api public */ exports.Manager = __webpack_require__(9); exports.Socket = __webpack_require__(34); /***/ }), /* 1 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {'use strict'; /** * Module dependencies. */ var parseuri = __webpack_require__(2); var debug = __webpack_require__(3)('socket.io-client:url'); /** * Module exports. */ module.exports = url; /** * URL parser. * * @param {String} url * @param {Object} An object meant to mimic window.location. * Defaults to window.location. * @api public */ function url(uri, loc) { var obj = uri; // default to window.location loc = loc || global.location; if (null == uri) uri = loc.protocol + '//' + loc.host; // relative path support if ('string' === typeof uri) { if ('/' === uri.charAt(0)) { if ('/' === uri.charAt(1)) { uri = loc.protocol + uri; } else { uri = loc.host + uri; } } if (!/^(https?|wss?):\/\//.test(uri)) { if ('undefined' !== typeof loc) { uri = loc.protocol + '//' + uri; } else { uri = 'https://' + uri; } } // parse obj = parseuri(uri); } // make sure we treat `localhost:80` and `localhost` equally if (!obj.port) { if (/^(http|ws)$/.test(obj.protocol)) { obj.port = '80'; } else if (/^(http|ws)s$/.test(obj.protocol)) { obj.port = '443'; } } obj.path = obj.path || '/'; var ipv6 = obj.host.indexOf(':') !== -1; var host = ipv6 ? '[' + obj.host + ']' : obj.host; // define unique id obj.id = obj.protocol + '://' + host + ':' + obj.port; // define href obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : ':' + obj.port); return obj; } /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 2 */ /***/ (function(module, exports) { /** * Parses an URI * * @author Steven Levithan <stevenlevithan.com> (MIT license) * @api private */ var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/; var parts = [ 'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor' ]; module.exports = function parseuri(str) { var src = str, b = str.indexOf('['), e = str.indexOf(']'); if (b != -1 && e != -1) { str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length); } var m = re.exec(str || ''), uri = {}, i = 14; while (i--) { uri[parts[i]] = m[i] || ''; } if (b != -1 && e != -1) { uri.source = src; uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':'); uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':'); uri.ipv6uri = true; } return uri; }; /***/ }), /* 3 */ /***/ (function(module, exports) { "use strict"; module.exports = function () { return function () {}; }; /***/ }), /* 4 */ /***/ (function(module, exports, __webpack_require__) { /** * Module dependencies. */ var debug = __webpack_require__(3)('socket.io-parser'); var Emitter = __webpack_require__(5); var binary = __webpack_require__(6); var isArray = __webpack_require__(7); var isBuf = __webpack_require__(8); /** * Protocol version. * * @api public */ exports.protocol = 4; /** * Packet types. * * @api public */ exports.types = [ 'CONNECT', 'DISCONNECT', 'EVENT', 'ACK', 'ERROR', 'BINARY_EVENT', 'BINARY_ACK' ]; /** * Packet type `connect`. * * @api public */ exports.CONNECT = 0; /** * Packet type `disconnect`. * * @api public */ exports.DISCONNECT = 1; /** * Packet type `event`. * * @api public */ exports.EVENT = 2; /** * Packet type `ack`. * * @api public */ exports.ACK = 3; /** * Packet type `error`. * * @api public */ exports.ERROR = 4; /** * Packet type 'binary event' * * @api public */ exports.BINARY_EVENT = 5; /** * Packet type `binary ack`. For acks with binary arguments. * * @api public */ exports.BINARY_ACK = 6; /** * Encoder constructor. * * @api public */ exports.Encoder = Encoder; /** * Decoder constructor. * * @api public */ exports.Decoder = Decoder; /** * A socket.io Encoder instance * * @api public */ function Encoder() {} var ERROR_PACKET = exports.ERROR + '"encode error"'; /** * Encode a packet as a single string if non-binary, or as a * buffer sequence, depending on packet type. * * @param {Object} obj - packet object * @param {Function} callback - function to handle encodings (likely engine.write) * @return Calls callback with Array of encodings * @api public */ Encoder.prototype.encode = function(obj, callback){ if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) { encodeAsBinary(obj, callback); } else { var encoding = encodeAsString(obj); callback([encoding]); } }; /** * Encode packet as string. * * @param {Object} packet * @return {String} encoded * @api private */ function encodeAsString(obj) { // first is type var str = '' + obj.type; // attachments if we have them if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) { str += obj.attachments + '-'; } // if we have a namespace other than `/` // we append it followed by a comma `,` if (obj.nsp && '/' !== obj.nsp) { str += obj.nsp + ','; } // immediately followed by the id if (null != obj.id) { str += obj.id; } // json data if (null != obj.data) { var payload = tryStringify(obj.data); if (payload !== false) { str += payload; } else { return ERROR_PACKET; } } return str; } function tryStringify(str) { try { return JSON.stringify(str); } catch(e){ return false; } } /** * Encode packet as 'buffer sequence' by removing blobs, and * deconstructing packet into object with placeholders and * a list of buffers. * * @param {Object} packet * @return {Buffer} encoded * @api private */ function encodeAsBinary(obj, callback) { function writeEncoding(bloblessData) { var deconstruction = binary.deconstructPacket(bloblessData); var pack = encodeAsString(deconstruction.packet); var buffers = deconstruction.buffers; buffers.unshift(pack); // add packet info to beginning of data list callback(buffers); // write all the buffers } binary.removeBlobs(obj, writeEncoding); } /** * A socket.io Decoder instance * * @return {Object} decoder * @api public */ function Decoder() { this.reconstructor = null; } /** * Mix in `Emitter` with Decoder. */ Emitter(Decoder.prototype); /** * Decodes an ecoded packet string into packet JSON. * * @param {String} obj - encoded packet * @return {Object} packet * @api public */ Decoder.prototype.add = function(obj) { var packet; if (typeof obj === 'string') { packet = decodeString(obj); if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json this.reconstructor = new BinaryReconstructor(packet); // no attachments, labeled binary but no binary data to follow if (this.reconstructor.reconPack.attachments === 0) { this.emit('decoded', packet); } } else { // non-binary full packet this.emit('decoded', packet); } } else if (isBuf(obj) || obj.base64) { // raw binary data if (!this.reconstructor) { throw new Error('got binary data when not reconstructing a packet'); } else { packet = this.reconstructor.takeBinaryData(obj); if (packet) { // received final buffer this.reconstructor = null; this.emit('decoded', packet); } } } else { throw new Error('Unknown type: ' + obj); } }; /** * Decode a packet String (JSON data) * * @param {String} str * @return {Object} packet * @api private */ function decodeString(str) { var i = 0; // look up type var p = { type: Number(str.charAt(0)) }; if (null == exports.types[p.type]) { return error('unknown packet type ' + p.type); } // look up attachments if type binary if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) { var buf = ''; while (str.charAt(++i) !== '-') { buf += str.charAt(i); if (i == str.length) break; } if (buf != Number(buf) || str.charAt(i) !== '-') { throw new Error('Illegal attachments'); } p.attachments = Number(buf); } // look up namespace (if any) if ('/' === str.charAt(i + 1)) { p.nsp = ''; while (++i) { var c = str.charAt(i); if (',' === c) break; p.nsp += c; if (i === str.length) break; } } else { p.nsp = '/'; } // look up id var next = str.charAt(i + 1); if ('' !== next && Number(next) == next) { p.id = ''; while (++i) { var c = str.charAt(i); if (null == c || Number(c) != c) { --i; break; } p.id += str.charAt(i); if (i === str.length) break; } p.id = Number(p.id); } // look up json data if (str.charAt(++i)) { var payload = tryParse(str.substr(i)); var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload)); if (isPayloadValid) { p.data = payload; } else { return error('invalid payload'); } } return p; } function tryParse(str) { try { return JSON.parse(str); } catch(e){ return false; } } /** * Deallocates a parser's resources * * @api public */ Decoder.prototype.destroy = function() { if (this.reconstructor) { this.reconstructor.finishedReconstruction(); } }; /** * A manager of a binary event's 'buffer sequence'. Should * be constructed whenever a packet of type BINARY_EVENT is * decoded. * * @param {Object} packet * @return {BinaryReconstructor} initialized reconstructor * @api private */ function BinaryReconstructor(packet) { this.reconPack = packet; this.buffers = []; } /** * Method to be called when binary data received from connection * after a BINARY_EVENT packet. * * @param {Buffer | ArrayBuffer} binData - the raw binary data received * @return {null | Object} returns null if more binary data is expected or * a reconstructed packet object if all buffers have been received. * @api private */ BinaryReconstructor.prototype.takeBinaryData = function(binData) { this.buffers.push(binData); if (this.buffers.length === this.reconPack.attachments) { // done with buffer list var packet = binary.reconstructPacket(this.reconPack, this.buffers); this.finishedReconstruction(); return packet; } return null; }; /** * Cleans up binary packet reconstruction variables. * * @api private */ BinaryReconstructor.prototype.finishedReconstruction = function() { this.reconPack = null; this.buffers = []; }; function error(msg) { return { type: exports.ERROR, data: 'parser error: ' + msg }; } /***/ }), /* 5 */ /***/ (function(module, exports, __webpack_require__) { /** * Expose `Emitter`. */ if (true) { module.exports = Emitter; } /** * Initialize a new `Emitter`. * * @api public */ function Emitter(obj) { if (obj) return mixin(obj); }; /** * Mixin the emitter properties. * * @param {Object} obj * @return {Object} * @api private */ function mixin(obj) { for (var key in Emitter.prototype) { obj[key] = Emitter.prototype[key]; } return obj; } /** * Listen on the given `event` with `fn`. * * @param {String} event * @param {Function} fn * @return {Emitter} * @api public */ Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn){ this._callbacks = this._callbacks || {}; (this._callbacks['$' + event] = this._callbacks['$' + event] || []) .push(fn); return this; }; /** * Adds an `event` listener that will be invoked a single * time then automatically removed. * * @param {String} event * @param {Function} fn * @return {Emitter} * @api public */ Emitter.prototype.once = function(event, fn){ function on() { this.off(event, on); fn.apply(this, arguments); } on.fn = fn; this.on(event, on); return this; }; /** * Remove the given callback for `event` or all * registered callbacks. * * @param {String} event * @param {Function} fn * @return {Emitter} * @api public */ Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn){ this._callbacks = this._callbacks || {}; // all if (0 == arguments.length) { this._callbacks = {}; return this; } // specific event var callbacks = this._callbacks['$' + event]; if (!callbacks) return this; // remove all handlers if (1 == arguments.length) { delete this._callbacks['$' + event]; return this; } // remove specific handler var cb; for (var i = 0; i < callbacks.length; i++) { cb = callbacks[i]; if (cb === fn || cb.fn === fn) { callbacks.splice(i, 1); break; } } return this; }; /** * Emit `event` with the given args. * * @param {String} event * @param {Mixed} ... * @return {Emitter} */ Emitter.prototype.emit = function(event){ this._callbacks = this._callbacks || {}; var args = [].slice.call(arguments, 1) , callbacks = this._callbacks['$' + event]; if (callbacks) { callbacks = callbacks.slice(0); for (var i = 0, len = callbacks.length; i < len; ++i) { callbacks[i].apply(this, args); } } return this; }; /** * Return array of callbacks for `event`. * * @param {String} event * @return {Array} * @api public */ Emitter.prototype.listeners = function(event){ this._callbacks = this._callbacks || {}; return this._callbacks['$' + event] || []; }; /** * Check if this emitter has `event` handlers. * * @param {String} event * @return {Boolean} * @api public */ Emitter.prototype.hasListeners = function(event){ return !! this.listeners(event).length; }; /***/ }), /* 6 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/ /** * Module requirements */ var isArray = __webpack_require__(7); var isBuf = __webpack_require__(8); var toString = Object.prototype.toString; var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]'; var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]'; /** * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder. * Anything with blobs or files should be fed through removeBlobs before coming * here. * * @param {Object} packet - socket.io event packet * @return {Object} with deconstructed packet and list of buffers * @api public */ exports.deconstructPacket = function(packet) { var buffers = []; var packetData = packet.data; var pack = packet; pack.data = _deconstructPacket(packetData, buffers); pack.attachments = buffers.length; // number of binary 'attachments' return {packet: pack, buffers: buffers}; }; function _deconstructPacket(data, buffers) { if (!data) return data; if (isBuf(data)) { var placeholder = { _placeholder: true, num: buffers.length }; buffers.push(data); return placeholder; } else if (isArray(data)) { var newData = new Array(data.length); for (var i = 0; i < data.length; i++) { newData[i] = _deconstructPacket(data[i], buffers); } return newData; } else if (typeof data === 'object' && !(data instanceof Date)) { var newData = {}; for (var key in data) { newData[key] = _deconstructPacket(data[key], buffers); } return newData; } return data; } /** * Reconstructs a binary packet from its placeholder packet and buffers * * @param {Object} packet - event packet with placeholders * @param {Array} buffers - binary buffers to put in placeholder positions * @return {Object} reconstructed packet * @api public */ exports.reconstructPacket = function(packet, buffers) { packet.data = _reconstructPacket(packet.data, buffers); packet.attachments = undefined; // no longer useful return packet; }; function _reconstructPacket(data, buffers) { if (!data) return data; if (data && data._placeholder) { return buffers[data.num]; // appropriate buffer (should be natural order anyway) } else if (isArray(data)) { for (var i = 0; i < data.length; i++) { data[i] = _reconstructPacket(data[i], buffers); } } else if (typeof data === 'object') { for (var key in data) { data[key] = _reconstructPacket(data[key], buffers); } } return data; } /** * Asynchronously removes Blobs or Files from data via * FileReader's readAsArrayBuffer method. Used before encoding * data as msgpack. Calls callback with the blobless data. * * @param {Object} data * @param {Function} callback * @api private */ exports.removeBlobs = function(data, callback) { function _removeBlobs(obj, curKey, containingObject) { if (!obj) return obj; // convert any blob if ((withNativeBlob && obj instanceof Blob) || (withNativeFile && obj instanceof File)) { pendingBlobs++; // async filereader var fileReader = new FileReader(); fileReader.onload = function() { // this.result == arraybuffer if (containingObject) { containingObject[curKey] = this.result; } else { bloblessData = this.result; } // if nothing pending its callback time if(! --pendingBlobs) { callback(bloblessData); } }; fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer } else if (isArray(obj)) { // handle array for (var i = 0; i < obj.length; i++) { _removeBlobs(obj[i], i, obj); } } else if (typeof obj === 'object' && !isBuf(obj)) { // and object for (var key in obj) { _removeBlobs(obj[key], key, obj); } } } var pendingBlobs = 0; var bloblessData = data; _removeBlobs(bloblessData); if (!pendingBlobs) { callback(bloblessData); } }; /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 7 */ /***/ (function(module, exports) { var toString = {}.toString; module.exports = Array.isArray || function (arr) { return toString.call(arr) == '[object Array]'; }; /***/ }), /* 8 */ /***/ (function(module, exports) { /* WEBPACK VAR INJECTION */(function(global) { module.exports = isBuf; var withNativeBuffer = typeof global.Buffer === 'function' && typeof global.Buffer.isBuffer === 'function'; var withNativeArrayBuffer = typeof global.ArrayBuffer === 'function'; var isView = (function () { if (withNativeArrayBuffer && typeof global.ArrayBuffer.isView === 'function') { return global.ArrayBuffer.isView; } else { return function (obj) { return obj.buffer instanceof global.ArrayBuffer; }; } })(); /** * Returns true if obj is a buffer or an arraybuffer. * * @api private */ function isBuf(obj) { return (withNativeBuffer && global.Buffer.isBuffer(obj)) || (withNativeArrayBuffer && (obj instanceof global.ArrayBuffer || isView(obj))); } /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 9 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /** * Module dependencies. */ var eio = __webpack_require__(10); var Socket = __webpack_require__(34); var Emitter = __webpack_require__(5); var parser = __webpack_require__(4); var on = __webpack_require__(36); var bind = __webpack_require__(37); var debug = __webpack_require__(3)('socket.io-client:manager'); var indexOf = __webpack_require__(33); var Backoff = __webpack_require__(38); /** * IE6+ hasOwnProperty */ var has = Object.prototype.hasOwnProperty; /** * Module exports */ module.exports = Manager; /** * `Manager` constructor. * * @param {String} engine instance or engine uri/opts * @param {Object} options * @api public */ function Manager(uri, opts) { if (!(this instanceof Manager)) return new Manager(uri, opts); if (uri && 'object' === (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) { opts = uri; uri = undefined; } opts = opts || {}; opts.path = opts.path || '/socket.io'; this.nsps = {}; this.subs = []; this.opts = opts; this.reconnection(opts.reconnection !== false); this.reconnectionAttempts(opts.reconnectionAttempts || Infinity); this.reconnectionDelay(opts.reconnectionDelay || 1000); this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000); this.randomizationFactor(opts.randomizationFactor || 0.5); this.backoff = new Backoff({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }); this.timeout(null == opts.timeout ? 20000 : opts.timeout); this.readyState = 'closed'; this.uri = uri; this.connecting = []; this.lastPing = null; this.encoding = false; this.packetBuffer = []; var _parser = opts.parser || parser; this.encoder = new _parser.Encoder(); this.decoder = new _parser.Decoder(); this.autoConnect = opts.autoConnect !== false; if (this.autoConnect) this.open(); } /** * Propagate given event to sockets and emit on `this` * * @api private */ Manager.prototype.emitAll = function () { this.emit.apply(this, arguments); for (var nsp in this.nsps) { if (has.call(this.nsps, nsp)) { this.nsps[nsp].emit.apply(this.nsps[nsp], arguments); } } }; /** * Update `socket.id` of all sockets * * @api private */ Manager.prototype.updateSocketIds = function () { for (var nsp in this.nsps) { if (has.call(this.nsps, nsp)) { this.nsps[nsp].id = this.generateId(nsp); } } }; /** * generate `socket.id` for the given `nsp` * * @param {String} nsp * @return {String} * @api private */ Manager.prototype.generateId = function (nsp) { return (nsp === '/' ? '' : nsp + '#') + this.engine.id; }; /** * Mix in `Emitter`. */ Emitter(Manager.prototype); /** * Sets the `reconnection` config. * * @param {Boolean} true/false if it should automatically reconnect * @return {Manager} self or value * @api public */ Manager.prototype.reconnection = function (v) { if (!arguments.length) return this._reconnection; this._reconnection = !!v; return this; }; /** * Sets the reconnection attempts config. * * @param {Number} max reconnection attempts before giving up * @return {Manager} self or value * @api public */ Manager.prototype.reconnectionAttempts = function (v) { if (!arguments.length) return this._reconnectionAttempts; this._reconnectionAttempts = v; return this; }; /** * Sets the delay between reconnections. * * @param {Number} delay * @return {Manager} self or value * @api public */ Manager.prototype.reconnectionDelay = function (v) { if (!arguments.length) return this._reconnectionDelay; this._reconnectionDelay = v; this.backoff && this.backoff.setMin(v); return this; }; Manager.prototype.randomizationFactor = function (v) { if (!arguments.length) return this._randomizationFactor; this._randomizationFactor = v; this.backoff && this.backoff.setJitter(v); return this; }; /** * Sets the maximum delay between reconnections. * * @param {Number} delay * @return {Manager} self or value * @api public */ Manager.prototype.reconnectionDelayMax = function (v) { if (!arguments.length) return this._reconnectionDelayMax; this._reconnectionDelayMax = v; this.backoff && this.backoff.setMax(v); return this; }; /** * Sets the connection timeout. `false` to disable * * @return {Manager} self or value * @api public */ Manager.prototype.timeout = function (v) { if (!arguments.length) return this._timeout; this._timeout = v; return this; }; /** * Starts trying to reconnect if reconnection is enabled and we have not * started reconnecting yet * * @api private */ Manager.prototype.maybeReconnectOnOpen = function () { // Only try to reconnect if it's the first time we're connecting if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) { // keeps reconnection from firing twice for the same reconnection loop this.reconnect(); } }; /** * Sets the current transport `socket`. * * @param {Function} optional, callback * @return {Manager} self * @api public */ Manager.prototype.open = Manager.prototype.connect = function (fn, opts) { if (~this.readyState.indexOf('open')) return this; this.engine = eio(this.uri, this.opts); var socket = this.engine; var self = this; this.readyState = 'opening'; this.skipReconnect = false; // emit `open` var openSub = on(socket, 'open', function () { self.onopen(); fn && fn(); }); // emit `connect_error` var errorSub = on(socket, 'error', function (data) { self.cleanup(); self.readyState = 'closed'; self.emitAll('connect_error', data); if (fn) { var err = new Error('Connection error'); err.data = data; fn(err); } else { // Only do this if there is no fn to handle the error self.maybeReconnectOnOpen(); } }); // emit `connect_timeout` if (false !== this._timeout) { var timeout = this._timeout; // set timer var timer = setTimeout(function () { openSub.destroy(); socket.close(); socket.emit('error', 'timeout'); self.emitAll('connect_timeout', timeout); }, timeout); this.subs.push({ destroy: function destroy() { clearTimeout(timer); } }); } this.subs.push(openSub); this.subs.push(errorSub); return this; }; /** * Called upon transport open. * * @api private */ Manager.prototype.onopen = function () { // clear old subs this.cleanup(); // mark as open this.readyState = 'open'; this.emit('open'); // add new subs var socket = this.engine; this.subs.push(on(socket, 'data', bind(this, 'ondata'))); this.subs.push(on(socket, 'ping', bind(this, 'onping'))); this.subs.push(on(socket, 'pong', bind(this, 'onpong'))); this.subs.push(on(socket, 'error', bind(this, 'onerror'))); this.subs.push(on(socket, 'close', bind(this, 'onclose'))); this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded'))); }; /** * Called upon a ping. * * @api private */ Manager.prototype.onping = function () { this.lastPing = new Date(); this.emitAll('ping'); }; /** * Called upon a packet. * * @api private */ Manager.prototype.onpong = function () { this.emitAll('pong', new Date() - this.lastPing); }; /** * Called with data. * * @api private */ Manager.prototype.ondata = function (data) { this.decoder.add(data); }; /** * Called when parser fully decodes a packet. * * @api private */ Manager.prototype.ondecoded = function (packet) { this.emit('packet', packet); }; /** * Called upon socket error. * * @api private */ Manager.prototype.onerror = function (err) { this.emitAll('error', err); }; /** * Creates a new socket for the given `nsp`. * * @return {Socket} * @api public */ Manager.prototype.socket = function (nsp, opts) { var socket = this.nsps[nsp]; if (!socket) { socket = new Socket(this, nsp, opts); this.nsps[nsp] = socket; var self = this; socket.on('connecting', onConnecting); socket.on('connect', function () { socket.id = self.generateId(nsp); }); if (this.autoConnect) { // manually call here since connecting event is fired before listening onConnecting(); } } function onConnecting() { if (!~indexOf(self.connecting, socket)) { self.connecting.push(socket); } } return socket; }; /** * Called upon a socket close. * * @param {Socket} socket */ Manager.prototype.destroy = function (socket) { var index = indexOf(this.connecting, socket); if (~index) this.connecting.splice(index, 1); if (this.connecting.length) return; this.close(); }; /** * Writes a packet. * * @param {Object} packet * @api private */ Manager.prototype.packet = function (packet) { var self = this; if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query; if (!self.encoding) { // encode, then write to engine with result self.encoding = true; this.encoder.encode(packet, function (encodedPackets) { for (var i = 0; i < encodedPackets.length; i++) { self.engine.write(encodedPackets[i], packet.options); } self.encoding = false; self.processPacketQueue(); }); } else { // add packet to the queue self.packetBuffer.push(packet); } }; /** * If packet buffer is non-empty, begins encoding the * next packet in line. * * @api private */ Manager.prototype.processPacketQueue = function () { if (this.packetBuffer.length > 0 && !this.encoding) { var pack = this.packetBuffer.shift(); this.packet(pack); } }; /** * Clean up transport subscriptions and packet buffer. * * @api private */ Manager.prototype.cleanup = function () { var subsLength = this.subs.length; for (var i = 0; i < subsLength; i++) { var sub = this.subs.shift(); sub.destroy(); } this.packetBuffer = []; this.encoding = false; this.lastPing = null; this.decoder.destroy(); }; /** * Close the current socket. * * @api private */ Manager.prototype.close = Manager.prototype.disconnect = function () { this.skipReconnect = true; this.reconnecting = false; if ('opening' === this.readyState) { // `onclose` will not fire because // an open event never happened this.cleanup(); } this.backoff.reset(); this.readyState = 'closed'; if (this.engine) this.engine.close(); }; /** * Called upon engine close. * * @api private */ Manager.prototype.onclose = function (reason) { this.cleanup(); this.backoff.reset(); this.readyState = 'closed'; this.emit('close', reason); if (this._reconnection && !this.skipReconnect) { this.reconnect(); } }; /** * Attempt a reconnection. * * @api private */ Manager.prototype.reconnect = function () { if (this.reconnecting || this.skipReconnect) return this; var self = this; if (this.backoff.attempts >= this._reconnectionAttempts) { this.backoff.reset(); this.emitAll('reconnect_failed'); this.reconnecting = false; } else { var delay = this.backoff.duration(); this.reconnecting = true; var timer = setTimeout(function () { if (self.skipReconnect) return; self.emitAll('reconnect_attempt', self.backoff.attempts); self.emitAll('reconnecting', self.backoff.attempts); // check again for the case socket closed in above events if (self.skipReconnect) return; self.open(function (err) { if (err) { self.reconnecting = false; self.reconnect(); self.emitAll('reconnect_error', err.data); } else { self.onreconnect(); } }); }, delay); this.subs.push({ destroy: function destroy() { clearTimeout(timer); } }); } }; /** * Called upon successful reconnect. * * @api private */ Manager.prototype.onreconnect = function () { var attempt = this.backoff.attempts; this.reconnecting = false; this.backoff.reset(); this.updateSocketIds(); this.emitAll('reconnect', attempt); }; /***/ }), /* 10 */ /***/ (function(module, exports, __webpack_require__) { module.exports = __webpack_require__(11); /** * Exports parser * * @api public * */ module.exports.parser = __webpack_require__(18); /***/ }), /* 11 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {/** * Module dependencies. */ var transports = __webpack_require__(12); var Emitter = __webpack_require__(5); var debug = __webpack_require__(3)('engine.io-client:socket'); var index = __webpack_require__(33); var parser = __webpack_require__(18); var parseuri = __webpack_require__(2); var parseqs = __webpack_require__(27); /** * Module exports. */ module.exports = Socket; /** * Socket constructor. * * @param {String|Object} uri or options * @param {Object} options * @api public */ function Socket (uri, opts) { if (!(this instanceof Socket)) return new Socket(uri, opts); opts = opts || {}; if (uri && 'object' === typeof uri) { opts = uri; uri = null; } if (uri) { uri = parseuri(uri); opts.hostname = uri.host; opts.secure = uri.protocol === 'https' || uri.protocol === 'wss'; opts.port = uri.port; if (uri.query) opts.query = uri.query; } else if (opts.host) { opts.hostname = parseuri(opts.host).host; } this.secure = null != opts.secure ? opts.secure : (global.location && 'https:' === location.protocol); if (opts.hostname && !opts.port) { // if no port is specified manually, use the protocol default opts.port = this.secure ? '443' : '80'; } this.agent = opts.agent || false; this.hostname = opts.hostname || (global.location ? location.hostname : 'localhost'); this.port = opts.port || (global.location && location.port ? location.port : (this.secure ? 443 : 80)); this.query = opts.query || {}; if ('string' === typeof this.query) this.query = parseqs.decode(this.query); this.upgrade = false !== opts.upgrade; this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/'; this.forceJSONP = !!opts.forceJSONP; this.jsonp = false !== opts.jsonp; this.forceBase64 = !!opts.forceBase64; this.enablesXDR = !!opts.enablesXDR; this.timestampParam = opts.timestampParam || 't'; this.timestampRequests = opts.timestampRequests; this.transports = opts.transports || ['polling', 'websocket']; this.transportOptions = opts.transportOptions || {}; this.readyState = ''; this.writeBuffer = []; this.prevBufferLen = 0; this.policyPort = opts.policyPort || 843; this.rememberUpgrade = opts.rememberUpgrade || false; this.binaryType = null; this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades; this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false; if (true === this.perMessageDeflate) this.perMessageDeflate = {}; if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) { this.perMessageDeflate.threshold = 1024; } // SSL options for Node.js client this.pfx = opts.pfx || null; this.key = opts.key || null; this.passphrase = opts.passphrase || null; this.cert = opts.cert || null; this.ca = opts.ca || null; this.ciphers = opts.ciphers || null; this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized; this.forceNode = !!opts.forceNode; // other options for Node.js client var freeGlobal = typeof global === 'object' && global; if (freeGlobal.global === freeGlobal) { if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) { this.extraHeaders = opts.extraHeaders; } if (opts.localAddress) { this.localAddress = opts.localAddress; } } // set on handshake this.id = null; this.upgrades = null; this.pingInterval = null; this.pingTimeout = null; // set on heartbeat this.pingIntervalTimer = null; this.pingTimeoutTimer = null; this.open(); } Socket.priorWebsocketSuccess = false; /** * Mix in `Emitter`. */ Emitter(Socket.prototype); /** * Protocol version. * * @api public */ Socket.protocol = parser.protocol; // this is an int /** * Expose deps for legacy compatibility * and standalone browser access. */ Socket.Socket = Socket; Socket.Transport = __webpack_require__(17); Socket.transports = __webpack_require__(12); Socket.parser = __webpack_require__(18); /** * Creates transport of the given type. * * @param {String} transport name * @return {Transport} * @api private */ Socket.prototype.createTransport = function (name) { var query = clone(this.query); // append engine.io protocol identifier query.EIO = parser.protocol; // transport name query.transport = name; // per-transport options var options = this.transportOptions[name] || {}; // session id if we already have one if (this.id) query.sid = this.id; var transport = new transports[name]({ query: query, socket: this, agent: options.agent || this.agent, hostname: options.hostname || this.hostname, port: options.port || this.port, secure: options.secure || this.secure, path: options.path || this.path, forceJSONP: options.forceJSONP || this.forceJSONP, jsonp: options.jsonp || this.jsonp, forceBase64: options.forceBase64 || this.forceBase64, enablesXDR: options.enablesXDR || this.enablesXDR, timestampRequests: options.timestampRequests || this.timestampRequests, timestampParam: options.timestampParam || this.timestampParam, policyPort: options.policyPort || this.policyPort, pfx: options.pfx || this.pfx, key: options.key || this.key, passphrase: options.passphrase || this.passphrase, cert: options.cert || this.cert, ca: options.ca || this.ca, ciphers: options.ciphers || this.ciphers, rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized, perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate, extraHeaders: options.extraHeaders || this.extraHeaders, forceNode: options.forceNode || this.forceNode, localAddress: options.localAddress || this.localAddress, requestTimeout: options.requestTimeout || this.requestTimeout, protocols: options.protocols || void (0) }); return transport; }; function clone (obj) { var o = {}; for (var i in obj) { if (obj.hasOwnProperty(i)) { o[i] = obj[i]; } } return o; } /** * Initializes transport to use and starts probe. * * @api private */ Socket.prototype.open = function () { var transport; if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) { transport = 'websocket'; } else if (0 === this.transports.length) { // Emit error on next tick so it can be listened to var self = this; setTimeout(function () { self.emit('error', 'No transports available'); }, 0); return; } else { transport = this.transports[0]; } this.readyState = 'opening'; // Retry with the next transport if the transport is disabled (jsonp: false) try { transport = this.createTransport(transport); } catch (e) { this.transports.shift(); this.open(); return; } transport.open(); this.setTransport(transport); }; /** * Sets the current transport. Disables the existing one (if any). * * @api private */ Socket.prototype.setTransport = function (transport) { var self = this; if (this.transport) { this.transport.removeAllListeners(); } // set up transport this.transport = transport; // set up transport listeners transport .on('drain', function () { self.onDrain(); }) .on('packet', function (packet) { self.onPacket(packet); }) .on('error', function (e) { self.onError(e); }) .on('close', function () { self.onClose('transport close'); }); }; /** * Probes a transport. * * @param {String} transport name * @api private */ Socket.prototype.probe = function (name) { var transport = this.createTransport(name, { probe: 1 }); var failed = false; var self = this; Socket.priorWebsocketSuccess = false; function onTransportOpen () { if (self.onlyBinaryUpgrades) { var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary; failed = failed || upgradeLosesBinary; } if (failed) return; transport.send([{ type: 'ping', data: 'probe' }]); transport.once('packet', function (msg) { if (failed) return; if ('pong' === msg.type && 'probe' === msg.data) { self.upgrading = true; self.emit('upgrading', transport); if (!transport) return; Socket.priorWebsocketSuccess = 'websocket' === transport.name; self.transport.pause(function () { if (failed) return; if ('closed' === self.readyState) return; cleanup(); self.setTransport(transport); transport.send([{ type: 'upgrade' }]); self.emit('upgrade', transport); transport = null; self.upgrading = false; self.flush(); }); } else { var err = new Error('probe error'); err.transport = transport.name; self.emit('upgradeError', err); } }); } function freezeTransport () { if (failed) return; // Any callback called by transport should be ignored since now failed = true; cleanup(); transport.close(); transport = null; } // Handle any error that happens while probing function onerror (err) { var error = new Error('probe error: ' + err); error.transport = transport.name; freezeTransport(); self.emit('upgradeError', error); } function onTransportClose () { onerror('transport closed'); } // When the socket is closed while we're probing function onclose () { onerror('socket closed'); } // When the socket is upgraded while we're probing function onupgrade (to) { if (transport && to.name !== transport.name) { freezeTransport(); } } // Remove all listeners on the transport and on self function cleanup () { transport.removeListener('open', onTransportOpen); transport.removeListener('error', onerror); transport.removeListener('close', onTransportClose); self.removeListener('close', onclose); self.removeListener('upgrading', onupgrade); } transport.once('open', onTransportOpen); transport.once('error', onerror); transport.once('close', onTransportClose); this.once('close', onclose); this.once('upgrading', onupgrade); transport.open(); }; /** * Called when connection is deemed open. * * @api public */ Socket.prototype.onOpen = function () { this.readyState = 'open'; Socket.priorWebsocketSuccess = 'websocket' === this.transport.name; this.emit('open'); this.flush(); // we check for `readyState` in case an `open` // listener already closed the socket if ('open' === this.readyState && this.upgrade && this.transport.pause) { for (var i = 0, l = this.upgrades.length; i < l; i++) { this.probe(this.upgrades[i]); } } }; /** * Handles a packet. * * @api private */ Socket.prototype.onPacket = function (packet) { if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) { this.emit('packet', packet); // Socket is live - any packet counts this.emit('heartbeat'); switch (packet.type) { case 'open': this.onHandshake(JSON.parse(packet.data)); break; case 'pong': this.setPing(); this.emit('pong'); break; case 'error': var err = new Error('server error'); err.code = packet.data; this.onError(err); break; case 'message': this.emit('data', packet.data); this.emit('message', packet.data); break; } } else { } }; /** * Called upon handshake completion. * * @param {Object} handshake obj * @api private */ Socket.prototype.onHandshake = function (data) { this.emit('handshake', data); this.id = data.sid; this.transport.query.sid = data.sid; this.upgrades = this.filterUpgrades(data.upgrades); this.pingInterval = data.pingInterval; this.pingTimeout = data.pingTimeout; this.onOpen(); // In case open handler closes socket if ('closed' === this.readyState) return; this.setPing(); // Prolong liveness of socket on heartbeat this.removeListener('heartbeat', this.onHeartbeat); this.on('heartbeat', this.onHeartbeat); }; /** * Resets ping timeout. * * @api private */ Socket.prototype.onHeartbeat = function (timeout) { clearTimeout(this.pingTimeoutTimer); var self = this; self.pingTimeoutTimer = setTimeout(function () { if ('closed' === self.readyState) return; self.onClose('ping timeout'); }, timeout || (self.pingInterval + self.pingTimeout)); }; /** * Pings server every `this.pingInterval` and expects response * within `this.pingTimeout` or closes connection. * * @api private */ Socket.prototype.setPing = function () { var self = this; clearTimeout(self.pingIntervalTimer); self.pingIntervalTimer = setTimeout(function () { self.ping(); self.onHeartbeat(self.pingTimeout); }, self.pingInterval); }; /** * Sends a ping packet. * * @api private */ Socket.prototype.ping = function () { var self = this; this.sendPacket('ping', function () { self.emit('ping'); }); }; /** * Called on `drain` event * * @api private */ Socket.prototype.onDrain = function () { this.writeBuffer.splice(0, this.prevBufferLen); // setting prevBufferLen = 0 is very important // for example, when upgrading, upgrade packet is sent over, // and a nonzero prevBufferLen could cause problems on `drain` this.prevBufferLen = 0; if (0 === this.writeBuffer.length) { this.emit('drain'); } else { this.flush(); } }; /** * Flush write buffers. * * @api private */ Socket.prototype.flush = function () { if ('closed' !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) { this.transport.send(this.writeBuffer); // keep track of current length of writeBuffer // splice writeBuffer and callbackBuffer on `drain` this.prevBufferLen = this.writeBuffer.length; this.emit('flush'); } }; /** * Sends a message. * * @param {String} message. * @param {Function} callback function. * @param {Object} options. * @return {Socket} for chaining. * @api public */ Socket.prototype.write = Socket.prototype.send = function (msg, options, fn) { this.sendPacket('message', msg, options, fn); return this; }; /** * Sends a packet. * * @param {String} packet type. * @param {String} data. * @param {Object} options. * @param {Function} callback function. * @api private */ Socket.prototype.sendPacket = function (type, data, options, fn) { if ('function' === typeof data) { fn = data; data = undefined; } if ('function' === typeof options) { fn = options; options = null; } if ('closing' === this.readyState || 'closed' === this.readyState) { return; } options = options || {}; options.compress = false !== options.compress; var packet = { type: type, data: data, options: options }; this.emit('packetCreate', packet); this.writeBuffer.push(packet); if (fn) this.once('flush', fn); this.flush(); }; /** * Closes the connection. * * @api private */ Socket.prototype.close = function () { if ('opening' === this.readyState || 'open' === this.readyState) { this.readyState = 'closing'; var self = this; if (this.writeBuffer.length) { this.once('drain', function () { if (this.upgrading) { waitForUpgrade(); } else { close(); } }); } else if (this.upgrading) { waitForUpgrade(); } else { close(); } } function close () { self.onClose('forced close'); self.transport.close(); } function cleanupAndClose () { self.removeListener('upgrade', cleanupAndClose); self.removeListener('upgradeError', cleanupAndClose); close(); } function waitForUpgrade () { // wait for upgrade to finish since we can't send packets while pausing a transport self.once('upgrade', cleanupAndClose); self.once('upgradeError', cleanupAndClose); } return this; }; /** * Called upon transport error * * @api private */ Socket.prototype.onError = function (err) { Socket.priorWebsocketSuccess = false; this.emit('error', err); this.onClose('transport error', err); }; /** * Called upon transport close. * * @api private */ Socket.prototype.onClose = function (reason, desc) { if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) { var self = this; // clear timers clearTimeout(this.pingIntervalTimer); clearTimeout(this.pingTimeoutTimer); // stop event from firing again for transport this.transport.removeAllListeners('close'); // ensure transport won't stay open this.transport.close(); // ignore further transport communication this.transport.removeAllListeners(); // set ready state this.readyState = 'closed'; // clear session id this.id = null; // emit close event this.emit('close', reason, desc); // clean buffers after, so users can still // grab the buffers on `close` event self.writeBuffer = []; self.prevBufferLen = 0; } }; /** * Filters upgrades, returning only those matching client transports. * * @param {Array} server upgrades * @api private * */ Socket.prototype.filterUpgrades = function (upgrades) { var filteredUpgrades = []; for (var i = 0, j = upgrades.length; i < j; i++) { if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]); } return filteredUpgrades; }; /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 12 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {/** * Module dependencies */ var XMLHttpRequest = __webpack_require__(13); var XHR = __webpack_require__(15); var JSONP = __webpack_require__(30); var websocket = __webpack_require__(31); /** * Export transports. */ exports.polling = polling; exports.websocket = websocket; /** * Polling transport polymorphic constructor. * Decides on xhr vs jsonp based on feature detection. * * @api private */ function polling (opts) { var xhr; var xd = false; var xs = false; var jsonp = false !== opts.jsonp; if (global.location) { var isSSL = 'https:' === location.protocol; var port = location.port; // some user agents have empty `location.port` if (!port) { port = isSSL ? 443 : 80; } xd = opts.hostname !== location.hostname || port !== opts.port; xs = opts.secure !== isSSL; } opts.xdomain = xd; opts.xscheme = xs; xhr = new XMLHttpRequest(opts); if ('open' in xhr && !opts.forceJSONP) { return new XHR(opts); } else { if (!jsonp) throw new Error('JSONP disabled'); return new JSONP(opts); } } /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 13 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {// browser shim for xmlhttprequest module var hasCORS = __webpack_require__(14); module.exports = function (opts) { var xdomain = opts.xdomain; // scheme must be same when usign XDomainRequest // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx var xscheme = opts.xscheme; // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default. // https://github.com/Automattic/engine.io-client/pull/217 var enablesXDR = opts.enablesXDR; // XMLHttpRequest can be disabled on IE try { if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) { return new XMLHttpRequest(); } } catch (e) { } // Use XDomainRequest for IE8 if enablesXDR is true // because loading bar keeps flashing when using jsonp-polling // https://github.com/yujiosaka/socke.io-ie8-loading-example try { if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) { return new XDomainRequest(); } } catch (e) { } if (!xdomain) { try { return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP'); } catch (e) { } } }; /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 14 */ /***/ (function(module, exports) { /** * Module exports. * * Logic borrowed from Modernizr: * * - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js */ try { module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest(); } catch (err) { // if XMLHttp support is disabled in IE then it will throw // when trying to create module.exports = false; } /***/ }), /* 15 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {/** * Module requirements. */ var XMLHttpRequest = __webpack_require__(13); var Polling = __webpack_require__(16); var Emitter = __webpack_require__(5); var inherit = __webpack_require__(28); var debug = __webpack_require__(3)('engine.io-client:polling-xhr'); /** * Module exports. */ module.exports = XHR; module.exports.Request = Request; /** * Empty function */ function empty () {} /** * XHR Polling constructor. * * @param {Object} opts * @api public */ function XHR (opts) { Polling.call(this, opts); this.requestTimeout = opts.requestTimeout; this.extraHeaders = opts.extraHeaders; if (global.location) { var isSSL = 'https:' === location.protocol; var port = location.port; // some user agents have empty `location.port` if (!port) { port = isSSL ? 443 : 80; } this.xd = opts.hostname !== global.location.hostname || port !== opts.port; this.xs = opts.secure !== isSSL; } } /** * Inherits from Polling. */ inherit(XHR, Polling); /** * XHR supports binary */ XHR.prototype.supportsBinary = true; /** * Creates a request. * * @param {String} method * @api private */ XHR.prototype.request = function (opts) { opts = opts || {}; opts.uri = this.uri(); opts.xd = this.xd; opts.xs = this.xs; opts.agent = this.agent || false; opts.supportsBinary = this.supportsBinary; opts.enablesXDR = this.enablesXDR; // SSL options for Node.js client opts.pfx = this.pfx; opts.key = this.key; opts.passphrase = this.passphrase; opts.cert = this.cert; opts.ca = this.ca; opts.ciphers = this.ciphers; opts.rejectUnauthorized = this.rejectUnauthorized; opts.requestTimeout = this.requestTimeout; // other options for Node.js client opts.extraHeaders = this.extraHeaders; return new Request(opts); }; /** * Sends data. * * @param {String} data to send. * @param {Function} called upon flush. * @api private */ XHR.prototype.doWrite = function (data, fn) { var isBinary = typeof data !== 'string' && data !== undefined; var req = this.request({ method: 'POST', data: data, isBinary: isBinary }); var self = this; req.on('success', fn); req.on('error', function (err) { self.onError('xhr post error', err); }); this.sendXhr = req; }; /** * Starts a poll cycle. * * @api private */ XHR.prototype.doPoll = function () { var req = this.request(); var self = this; req.on('data', function (data) { self.onData(data); }); req.on('error', function (err) { self.onError('xhr poll error', err); }); this.pollXhr = req; }; /** * Request constructor * * @param {Object} options * @api public */ function Request (opts) { this.method = opts.method || 'GET'; this.uri = opts.uri; this.xd = !!opts.xd; this.xs = !!opts.xs; this.async = false !== opts.async; this.data = undefined !== opts.data ? opts.data : null; this.agent = opts.agent; this.isBinary = opts.isBinary; this.supportsBinary = opts.supportsBinary; this.enablesXDR = opts.enablesXDR; this.requestTimeout = opts.requestTimeout; // SSL options for Node.js client this.pfx = opts.pfx; this.key = opts.key; this.passphrase = opts.passphrase; this.cert = opts.cert; this.ca = opts.ca; this.ciphers = opts.ciphers; this.rejectUnauthorized = opts.rejectUnauthorized; // other options for Node.js client this.extraHeaders = opts.extraHeaders; this.create(); } /** * Mix in `Emitter`. */ Emitter(Request.prototype); /** * Creates the XHR object and sends the request. * * @api private */ Request.prototype.create = function () { var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR }; // SSL options for Node.js client opts.pfx = this.pfx; opts.key = this.key; opts.passphrase = this.passphrase; opts.cert = this.cert; opts.ca = this.ca; opts.ciphers = this.ciphers; opts.rejectUnauthorized = this.rejectUnauthorized; var xhr = this.xhr = new XMLHttpRequest(opts); var self = this; try { xhr.open(this.method, this.uri, this.async); try { if (this.extraHeaders) { xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true); for (var i in this.extraHeaders) { if (this.extraHeaders.hasOwnProperty(i)) { xhr.setRequestHeader(i, this.extraHeaders[i]); } } } } catch (e) {} if ('POST' === this.method) { try { if (this.isBinary) { xhr.setRequestHeader('Content-type', 'application/octet-stream'); } else { xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8'); } } catch (e) {} } try { xhr.setRequestHeader('Accept', '*/*'); } catch (e) {} // ie6 check if ('withCredentials' in xhr) { xhr.withCredentials = true; } if (this.requestTimeout) { xhr.timeout = this.requestTimeout; } if (this.hasXDR()) { xhr.onload = function () { self.onLoad(); }; xhr.onerror = function () { self.onError(xhr.responseText); }; } else { xhr.onreadystatechange = function () { if (xhr.readyState === 2) { try { var contentType = xhr.getResponseHeader('Content-Type'); if (self.supportsBinary && contentType === 'application/octet-stream') { xhr.responseType = 'arraybuffer'; } } catch (e) {} } if (4 !== xhr.readyState) return; if (200 === xhr.status || 1223 === xhr.status) { self.onLoad(); } else { // make sure the `error` event handler that's user-set // does not throw in the same tick and gets caught here setTimeout(function () { self.onError(xhr.status); }, 0); } }; } xhr.send(this.data); } catch (e) { // Need to defer since .create() is called directly fhrom the constructor // and thus the 'error' event can only be only bound *after* this exception // occurs. Therefore, also, we cannot throw here at all. setTimeout(function () { self.onError(e); }, 0); return; } if (global.document) { this.index = Request.requestsCount++; Request.requests[this.index] = this; } }; /** * Called upon successful response. * * @api private */ Request.prototype.onSuccess = function () { this.emit('success'); this.cleanup(); }; /** * Called if we have data. * * @api private */ Request.prototype.onData = function (data) { this.emit('data', data); this.onSuccess(); }; /** * Called upon error. * * @api private */ Request.prototype.onError = function (err) { this.emit('error', err); this.cleanup(true); }; /** * Cleans up house. * * @api private */ Request.prototype.cleanup = function (fromError) { if ('undefined' === typeof this.xhr || null === this.xhr) { return; } // xmlhttprequest if (this.hasXDR()) { this.xhr.onload = this.xhr.onerror = empty; } else { this.xhr.onreadystatechange = empty; } if (fromError) { try { this.xhr.abort(); } catch (e) {} } if (global.document) { delete Request.requests[this.index]; } this.xhr = null; }; /** * Called upon load. * * @api private */ Request.prototype.onLoad = function () { var data; try { var contentType; try { contentType = this.xhr.getResponseHeader('Content-Type'); } catch (e) {} if (contentType === 'application/octet-stream') { data = this.xhr.response || this.xhr.responseText; } else { data = this.xhr.responseText; } } catch (e) { this.onError(e); } if (null != data) { this.onData(data); } }; /** * Check if it has XDomainRequest. * * @api private */ Request.prototype.hasXDR = function () { return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR; }; /** * Aborts the request. * * @api public */ Request.prototype.abort = function () { this.cleanup(); }; /** * Aborts pending requests when unloading the window. This is needed to prevent * memory leaks (e.g. when using IE) and to ensure that no spurious error is * emitted. */ Request.requestsCount = 0; Request.requests = {}; if (global.document) { if (global.attachEvent) { global.attachEvent('onunload', unloadHandler); } else if (global.addEventListener) { global.addEventListener('beforeunload', unloadHandler, false); } } function unloadHandler () { for (var i in Request.requests) { if (Request.requests.hasOwnProperty(i)) { Request.requests[i].abort(); } } } /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 16 */ /***/ (function(module, exports, __webpack_require__) { /** * Module dependencies. */ var Transport = __webpack_require__(17); var parseqs = __webpack_require__(27); var parser = __webpack_require__(18); var inherit = __webpack_require__(28); var yeast = __webpack_require__(29); var debug = __webpack_require__(3)('engine.io-client:polling'); /** * Module exports. */ module.exports = Polling; /** * Is XHR2 supported? */ var hasXHR2 = (function () { var XMLHttpRequest = __webpack_require__(13); var xhr = new XMLHttpRequest({ xdomain: false }); return null != xhr.responseType; })(); /** * Polling interface. * * @param {Object} opts * @api private */ function Polling (opts) { var forceBase64 = (opts && opts.forceBase64); if (!hasXHR2 || forceBase64) { this.supportsBinary = false; } Transport.call(this, opts); } /** * Inherits from Transport. */ inherit(Polling, Transport); /** * Transport name. */ Polling.prototype.name = 'polling'; /** * Opens the socket (triggers polling). We write a PING message to determine * when the transport is open. * * @api private */ Polling.prototype.doOpen = function () { this.poll(); }; /** * Pauses polling. * * @param {Function} callback upon buffers are flushed and transport is paused * @api private */ Polling.prototype.pause = function (onPause) { var self = this; this.readyState = 'pausing'; function pause () { self.readyState = 'paused'; onPause(); } if (this.polling || !this.writable) { var total = 0; if (this.polling) { total++; this.once('pollComplete', function () { --total || pause(); }); } if (!this.writable) { total++; this.once('drain', function () { --total || pause(); }); } } else { pause(); } }; /** * Starts polling cycle. * * @api public */ Polling.prototype.poll = function () { this.polling = true; this.doPoll(); this.emit('poll'); }; /** * Overloads onData to detect payloads. * * @api private */ Polling.prototype.onData = function (data) { var self = this; var callback = function (packet, index, total) { // if its the first message we consider the transport open if ('opening' === self.readyState) { self.onOpen(); } // if its a close packet, we close the ongoing requests if ('close' === packet.type) { self.onClose(); return false; } // otherwise bypass onData and handle the message self.onPacket(packet); }; // decode payload parser.decodePayload(data, this.socket.binaryType, callback); // if an event did not trigger closing if ('closed' !== this.readyState) { // if we got data we're not polling this.polling = false; this.emit('pollComplete'); if ('open' === this.readyState) { this.poll(); } else { } } }; /** * For polling, send a close packet. * * @api private */ Polling.prototype.doClose = function () { var self = this; function close () { self.write([{ type: 'close' }]); } if ('open' === this.readyState) { close(); } else { // in case we're trying to close while // handshaking is in progress (GH-164) this.once('open', close); } }; /** * Writes a packets payload. * * @param {Array} data packets * @param {Function} drain callback * @api private */ Polling.prototype.write = function (packets) { var self = this; this.writable = false; var callbackfn = function () { self.writable = true; self.emit('drain'); }; parser.encodePayload(packets, this.supportsBinary, function (data) { self.doWrite(data, callbackfn); }); }; /** * Generates uri for connection. * * @api private */ Polling.prototype.uri = function () { var query = this.query || {}; var schema = this.secure ? 'https' : 'http'; var port = ''; // cache busting is forced if (false !== this.timestampRequests) { query[this.timestampParam] = yeast(); } if (!this.supportsBinary && !query.sid) { query.b64 = 1; } query = parseqs.encode(query); // avoid port if default for schema if (this.port && (('https' === schema && Number(this.port) !== 443) || ('http' === schema && Number(this.port) !== 80))) { port = ':' + this.port; } // prepend ? to query if (query.length) { query = '?' + query; } var ipv6 = this.hostname.indexOf(':') !== -1; return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query; }; /***/ }), /* 17 */ /***/ (function(module, exports, __webpack_require__) { /** * Module dependencies. */ var parser = __webpack_require__(18); var Emitter = __webpack_require__(5); /** * Module exports. */ module.exports = Transport; /** * Transport abstract constructor. * * @param {Object} options. * @api private */ function Transport (opts) { this.path = opts.path; this.hostname = opts.hostname; this.port = opts.port; this.secure = opts.secure; this.query = opts.query; this.timestampParam = opts.timestampParam; this.timestampRequests = opts.timestampRequests; this.readyState = ''; this.agent = opts.agent || false; this.socket = opts.socket; this.enablesXDR = opts.enablesXDR; // SSL options for Node.js client this.pfx = opts.pfx; this.key = opts.key; this.passphrase = opts.passphrase; this.cert = opts.cert; this.ca = opts.ca; this.ciphers = opts.ciphers; this.rejectUnauthorized = opts.rejectUnauthorized; this.forceNode = opts.forceNode; // other options for Node.js client this.extraHeaders = opts.extraHeaders; this.localAddress = opts.localAddress; } /** * Mix in `Emitter`. */ Emitter(Transport.prototype); /** * Emits an error. * * @param {String} str * @return {Transport} for chaining * @api public */ Transport.prototype.onError = function (msg, desc) { var err = new Error(msg); err.type = 'TransportError'; err.description = desc; this.emit('error', err); return this; }; /** * Opens the transport. * * @api public */ Transport.prototype.open = function () { if ('closed' === this.readyState || '' === this.readyState) { this.readyState = 'opening'; this.doOpen(); } return this; }; /** * Closes the transport. * * @api private */ Transport.prototype.close = function () { if ('opening' === this.readyState || 'open' === this.readyState) { this.doClose(); this.onClose(); } return this; }; /** * Sends multiple packets. * * @param {Array} packets * @api private */ Transport.prototype.send = function (packets) { if ('open' === this.readyState) { this.write(packets); } else { throw new Error('Transport not open'); } }; /** * Called upon open * * @api private */ Transport.prototype.onOpen = function () { this.readyState = 'open'; this.writable = true; this.emit('open'); }; /** * Called with data. * * @param {String} data * @api private */ Transport.prototype.onData = function (data) { var packet = parser.decodePacket(data, this.socket.binaryType); this.onPacket(packet); }; /** * Called with a decoded packet. */ Transport.prototype.onPacket = function (packet) { this.emit('packet', packet); }; /** * Called upon close. * * @api private */ Transport.prototype.onClose = function () { this.readyState = 'closed'; this.emit('close'); }; /***/ }), /* 18 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {/** * Module dependencies. */ var keys = __webpack_require__(19); var hasBinary = __webpack_require__(20); var sliceBuffer = __webpack_require__(21); var after = __webpack_require__(22); var utf8 = __webpack_require__(23); var base64encoder; if (global && global.ArrayBuffer) { base64encoder = __webpack_require__(25); } /** * Check if we are running an android browser. That requires us to use * ArrayBuffer with polling transports... * * http://ghinda.net/jpeg-blob-ajax-android/ */ var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent); /** * Check if we are running in PhantomJS. * Uploading a Blob with PhantomJS does not work correctly, as reported here: * https://github.com/ariya/phantomjs/issues/11395 * @type boolean */ var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent); /** * When true, avoids using Blobs to encode payloads. * @type boolean */ var dontSendBlobs = isAndroid || isPhantomJS; /** * Current protocol version. */ exports.protocol = 3; /** * Packet types. */ var packets = exports.packets = { open: 0 // non-ws , close: 1 // non-ws , ping: 2 , pong: 3 , message: 4 , upgrade: 5 , noop: 6 }; var packetslist = keys(packets); /** * Premade error packet. */ var err = { type: 'error', data: 'parser error' }; /** * Create a blob api even for blob builder when vendor prefixes exist */ var Blob = __webpack_require__(26); /** * Encodes a packet. * * <packet type id> [ <data> ] * * Example: * * 5hello world * 3 * 4 * * Binary is encoded in an identical principle * * @api private */ exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) { if (typeof supportsBinary === 'function') { callback = supportsBinary; supportsBinary = false; } if (typeof utf8encode === 'function') { callback = utf8encode; utf8encode = null; } var data = (packet.data === undefined) ? undefined : packet.data.buffer || packet.data; if (global.ArrayBuffer && data instanceof ArrayBuffer) { return encodeArrayBuffer(packet, supportsBinary, callback); } else if (Blob && data instanceof global.Blob) { return encodeBlob(packet, supportsBinary, callback); } // might be an object with { base64: true, data: dataAsBase64String } if (data && data.base64) { return encodeBase64Object(packet, callback); } // Sending data as a utf-8 string var encoded = packets[packet.type]; // data fragment is optional if (undefined !== packet.data) { encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data); } return callback('' + encoded); }; function encodeBase64Object(packet, callback) { // packet data is an object { base64: true, data: dataAsBase64String } var message = 'b' + exports.packets[packet.type] + packet.data.data; return callback(message); } /** * Encode packet helpers for binary types */ function encodeArrayBuffer(packet, supportsBinary, callback) { if (!supportsBinary) { return exports.encodeBase64Packet(packet, callback); } var data = packet.data; var contentArray = new Uint8Array(data); var resultBuffer = new Uint8Array(1 + data.byteLength); resultBuffer[0] = packets[packet.type]; for (var i = 0; i < contentArray.length; i++) { resultBuffer[i+1] = contentArray[i]; } return callback(resultBuffer.buffer); } function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) { if (!supportsBinary) { return exports.encodeBase64Packet(packet, callback); } var fr = new FileReader(); fr.onload = function() { packet.data = fr.result; exports.encodePacket(packet, supportsBinary, true, callback); }; return fr.readAsArrayBuffer(packet.data); } function encodeBlob(packet, supportsBinary, callback) { if (!supportsBinary) { return exports.encodeBase64Packet(packet, callback); } if (dontSendBlobs) { return encodeBlobAsArrayBuffer(packet, supportsBinary, callback); } var length = new Uint8Array(1); length[0] = packets[packet.type]; var blob = new Blob([length.buffer, packet.data]); return callback(blob); } /** * Encodes a packet with binary data in a base64 string * * @param {Object} packet, has `type` and `data` * @return {String} base64 encoded message */ exports.encodeBase64Packet = function(packet, callback) { var message = 'b' + exports.packets[packet.type]; if (Blob && packet.data instanceof global.Blob) { var fr = new FileReader(); fr.onload = function() { var b64 = fr.result.split(',')[1]; callback(message + b64); }; return fr.readAsDataURL(packet.data); } var b64data; try { b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data)); } catch (e) { // iPhone Safari doesn't let you apply with typed arrays var typed = new Uint8Array(packet.data); var basic = new Array(typed.length); for (var i = 0; i < typed.length; i++) { basic[i] = typed[i]; } b64data = String.fromCharCode.apply(null, basic); } message += global.btoa(b64data); return callback(message); }; /** * Decodes a packet. Changes format to Blob if requested. * * @return {Object} with `type` and `data` (if any) * @api private */ exports.decodePacket = function (data, binaryType, utf8decode) { if (data === undefined) { return err; } // String data if (typeof data === 'string') { if (data.charAt(0) === 'b') { return exports.decodeBase64Packet(data.substr(1), binaryType); } if (utf8decode) { data = tryDecode(data); if (data === false) { return err; } } var type = data.charAt(0); if (Number(type) != type || !packetslist[type]) { return err; } if (data.length > 1) { return { type: packetslist[type], data: data.substring(1) }; } else { return { type: packetslist[type] }; } } var asArray = new Uint8Array(data); var type = asArray[0]; var rest = sliceBuffer(data, 1); if (Blob && binaryType === 'blob') { rest = new Blob([rest]); } return { type: packetslist[type], data: rest }; }; function tryDecode(data) { try { data = utf8.decode(data, { strict: false }); } catch (e) { return false; } return data; } /** * Decodes a packet encoded in a base64 string * * @param {String} base64 encoded message * @return {Object} with `type` and `data` (if any) */ exports.decodeBase64Packet = function(msg, binaryType) { var type = packetslist[msg.charAt(0)]; if (!base64encoder) { return { type: type, data: { base64: true, data: msg.substr(1) } }; } var data = base64encoder.decode(msg.substr(1)); if (binaryType === 'blob' && Blob) { data = new Blob([data]); } return { type: type, data: data }; }; /** * Encodes multiple messages (payload). * * <length>:data * * Example: * * 11:hello world2:hi * * If any contents are binary, they will be encoded as base64 strings. Base64 * encoded strings are marked with a b before the length specifier * * @param {Array} packets * @api private */ exports.encodePayload = function (packets, supportsBinary, callback) { if (typeof supportsBinary === 'function') { callback = supportsBinary; supportsBinary = null; } var isBinary = hasBinary(packets); if (supportsBinary && isBinary) { if (Blob && !dontSendBlobs) { return exports.encodePayloadAsBlob(packets, callback); } return exports.encodePayloadAsArrayBuffer(packets, callback); } if (!packets.length) { return callback('0:'); } function setLengthHeader(message) { return message.length + ':' + message; } function encodeOne(packet, doneCallback) { exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) { doneCallback(null, setLengthHeader(message)); }); } map(packets, encodeOne, function(err, results) { return callback(results.join('')); }); }; /** * Async array map using after */ function map(ary, each, done) { var result = new Array(ary.length); var next = after(ary.length, done); var eachWithIndex = function(i, el, cb) { each(el, function(error, msg) { result[i] = msg; cb(error, result); }); }; for (var i = 0; i < ary.length; i++) { eachWithIndex(i, ary[i], next); } } /* * Decodes data when a payload is maybe expected. Possible binary contents are * decoded from their base64 representation * * @param {String} data, callback method * @api public */ exports.decodePayload = function (data, binaryType, callback) { if (typeof data !== 'string') { return exports.decodePayloadAsBinary(data, binaryType, callback); } if (typeof binaryType === 'function') { callback = binaryType; binaryType = null; } var packet; if (data === '') { // parser error - ignoring payload return callback(err, 0, 1); } var length = '', n, msg; for (var i = 0, l = data.length; i < l; i++) { var chr = data.charAt(i); if (chr !== ':') { length += chr; continue; } if (length === '' || (length != (n = Number(length)))) { // parser error - ignoring payload return callback(err, 0, 1); } msg = data.substr(i + 1, n); if (length != msg.length) { // parser error - ignoring payload return callback(err, 0, 1); } if (msg.length) { packet = exports.decodePacket(msg, binaryType, false); if (err.type === packet.type && err.data === packet.data) { // parser error in individual packet - ignoring payload return callback(err, 0, 1); } var ret = callback(packet, i + n, l); if (false === ret) return; } // advance cursor i += n; length = ''; } if (length !== '') { // parser error - ignoring payload return callback(err, 0, 1); } }; /** * Encodes multiple messages (payload) as binary. * * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number * 255><data> * * Example: * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers * * @param {Array} packets * @return {ArrayBuffer} encoded payload * @api private */ exports.encodePayloadAsArrayBuffer = function(packets, callback) { if (!packets.length) { return callback(new ArrayBuffer(0)); } function encodeOne(packet, doneCallback) { exports.encodePacket(packet, true, true, function(data) { return doneCallback(null, data); }); } map(packets, encodeOne, function(err, encodedPackets) { var totalLength = encodedPackets.reduce(function(acc, p) { var len; if (typeof p === 'string'){ len = p.length; } else { len = p.byteLength; } return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2 }, 0); var resultArray = new Uint8Array(totalLength); var bufferIndex = 0; encodedPackets.forEach(function(p) { var isString = typeof p === 'string'; var ab = p; if (isString) { var view = new Uint8Array(p.length); for (var i = 0; i < p.length; i++) { view[i] = p.charCodeAt(i); } ab = view.buffer; } if (isString) { // not true binary resultArray[bufferIndex++] = 0; } else { // true binary resultArray[bufferIndex++] = 1; } var lenStr = ab.byteLength.toString(); for (var i = 0; i < lenStr.length; i++) { resultArray[bufferIndex++] = parseInt(lenStr[i]); } resultArray[bufferIndex++] = 255; var view = new Uint8Array(ab); for (var i = 0; i < view.length; i++) { resultArray[bufferIndex++] = view[i]; } }); return callback(resultArray.buffer); }); }; /** * Encode as Blob */ exports.encodePayloadAsBlob = function(packets, callback) { function encodeOne(packet, doneCallback) { exports.encodePacket(packet, true, true, function(encoded) { var binaryIdentifier = new Uint8Array(1); binaryIdentifier[0] = 1; if (typeof encoded === 'string') { var view = new Uint8Array(encoded.length); for (var i = 0; i < encoded.length; i++) { view[i] = encoded.charCodeAt(i); } encoded = view.buffer; binaryIdentifier[0] = 0; } var len = (encoded instanceof ArrayBuffer) ? encoded.byteLength : encoded.size; var lenStr = len.toString(); var lengthAry = new Uint8Array(lenStr.length + 1); for (var i = 0; i < lenStr.length; i++) { lengthAry[i] = parseInt(lenStr[i]); } lengthAry[lenStr.length] = 255; if (Blob) { var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]); doneCallback(null, blob); } }); } map(packets, encodeOne, function(err, results) { return callback(new Blob(results)); }); }; /* * Decodes data when a payload is maybe expected. Strings are decoded by * interpreting each byte as a key code for entries marked to start with 0. See * description of encodePayloadAsBinary * * @param {ArrayBuffer} data, callback method * @api public */ exports.decodePayloadAsBinary = function (data, binaryType, callback) { if (typeof binaryType === 'function') { callback = binaryType; binaryType = null; } var bufferTail = data; var buffers = []; while (bufferTail.byteLength > 0) { var tailArray = new Uint8Array(bufferTail); var isString = tailArray[0] === 0; var msgLength = ''; for (var i = 1; ; i++) { if (tailArray[i] === 255) break; // 310 = char length of Number.MAX_VALUE if (msgLength.length > 310) { return callback(err, 0, 1); } msgLength += tailArray[i]; } bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length); msgLength = parseInt(msgLength); var msg = sliceBuffer(bufferTail, 0, msgLength); if (isString) { try { msg = String.fromCharCode.apply(null, new Uint8Array(msg)); } catch (e) { // iPhone Safari doesn't let you apply to typed arrays var typed = new Uint8Array(msg); msg = ''; for (var i = 0; i < typed.length; i++) { msg += String.fromCharCode(typed[i]); } } } buffers.push(msg); bufferTail = sliceBuffer(bufferTail, msgLength); } var total = buffers.length; buffers.forEach(function(buffer, i) { callback(exports.decodePacket(buffer, binaryType, true), i, total); }); }; /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 19 */ /***/ (function(module, exports) { /** * Gets the keys for an object. * * @return {Array} keys * @api private */ module.exports = Object.keys || function keys (obj){ var arr = []; var has = Object.prototype.hasOwnProperty; for (var i in obj) { if (has.call(obj, i)) { arr.push(i); } } return arr; }; /***/ }), /* 20 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {/* global Blob File */ /* * Module requirements. */ var isArray = __webpack_require__(7); var toString = Object.prototype.toString; var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]'; var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]'; /** * Module exports. */ module.exports = hasBinary; /** * Checks for binary data. * * Supports Buffer, ArrayBuffer, Blob and File. * * @param {Object} anything * @api public */ function hasBinary (obj) { if (!obj || typeof obj !== 'object') { return false; } if (isArray(obj)) { for (var i = 0, l = obj.length; i < l; i++) { if (hasBinary(obj[i])) { return true; } } return false; } if ((typeof global.Buffer === 'function' && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) || (typeof global.ArrayBuffer === 'function' && obj instanceof ArrayBuffer) || (withNativeBlob && obj instanceof Blob) || (withNativeFile && obj instanceof File) ) { return true; } // see: https://github.com/Automattic/has-binary/pull/4 if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) { return hasBinary(obj.toJSON(), true); } for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) { return true; } } return false; } /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 21 */ /***/ (function(module, exports) { /** * An abstraction for slicing an arraybuffer even when * ArrayBuffer.prototype.slice is not supported * * @api public */ module.exports = function(arraybuffer, start, end) { var bytes = arraybuffer.byteLength; start = start || 0; end = end || bytes; if (arraybuffer.slice) { return arraybuffer.slice(start, end); } if (start < 0) { start += bytes; } if (end < 0) { end += bytes; } if (end > bytes) { end = bytes; } if (start >= bytes || start >= end || bytes === 0) { return new ArrayBuffer(0); } var abv = new Uint8Array(arraybuffer); var result = new Uint8Array(end - start); for (var i = start, ii = 0; i < end; i++, ii++) { result[ii] = abv[i]; } return result.buffer; }; /***/ }), /* 22 */ /***/ (function(module, exports) { module.exports = after function after(count, callback, err_cb) { var bail = false err_cb = err_cb || noop proxy.count = count return (count === 0) ? callback() : proxy function proxy(err, result) { if (proxy.count <= 0) { throw new Error('after called too many times') } --proxy.count // after first error, rest are passed to err_cb if (err) { bail = true callback(err) // future error callbacks will go to error handler callback = err_cb } else if (proxy.count === 0 && !bail) { callback(null, result) } } } function noop() {} /***/ }), /* 23 */ /***/ (function(module, exports, __webpack_require__) { var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.1.2 by @mathias */ ;(function(root) { // Detect free variables `exports` var freeExports = typeof exports == 'object' && exports; // Detect free variable `module` var freeModule = typeof module == 'object' && module && module.exports == freeExports && module; // Detect free variable `global`, from Node.js or Browserified code, // and use it as `root` var freeGlobal = typeof global == 'object' && global; if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) { root = freeGlobal; } /*--------------------------------------------------------------------------*/ var stringFromCharCode = String.fromCharCode; // Taken from https://mths.be/punycode function ucs2decode(string) { var output = []; var counter = 0; var length = string.length; var value; var extra; while (counter < length) { value = string.charCodeAt(counter++); if (value >= 0xD800 && value <= 0xDBFF && counter < length) { // high surrogate, and there is a next character extra = string.charCodeAt(counter++); if ((extra & 0xFC00) == 0xDC00) { // low surrogate output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000); } else { // unmatched surrogate; only append this code unit, in case the next // code unit is the high surrogate of a surrogate pair output.push(value); counter--; } } else { output.push(value); } } return output; } // Taken from https://mths.be/punycode function ucs2encode(array) { var length = array.length; var index = -1; var value; var output = ''; while (++index < length) { value = array[index]; if (value > 0xFFFF) { value -= 0x10000; output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800); value = 0xDC00 | value & 0x3FF; } output += stringFromCharCode(value); } return output; } function checkScalarValue(codePoint, strict) { if (codePoint >= 0xD800 && codePoint <= 0xDFFF) { if (strict) { throw Error( 'Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value' ); } return false; } return true; } /*--------------------------------------------------------------------------*/ function createByte(codePoint, shift) { return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80); } function encodeCodePoint(codePoint, strict) { if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence return stringFromCharCode(codePoint); } var symbol = ''; if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0); } else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence if (!checkScalarValue(codePoint, strict)) { codePoint = 0xFFFD; } symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0); symbol += createByte(codePoint, 6); } else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0); symbol += createByte(codePoint, 12); symbol += createByte(codePoint, 6); } symbol += stringFromCharCode((codePoint & 0x3F) | 0x80); return symbol; } function utf8encode(string, opts) { opts = opts || {}; var strict = false !== opts.strict; var codePoints = ucs2decode(string); var length = codePoints.length; var index = -1; var codePoint; var byteString = ''; while (++index < length) { codePoint = codePoints[index]; byteString += encodeCodePoint(codePoint, strict); } return byteString; } /*--------------------------------------------------------------------------*/ function readContinuationByte() { if (byteIndex >= byteCount) { throw Error('Invalid byte index'); } var continuationByte = byteArray[byteIndex] & 0xFF; byteIndex++; if ((continuationByte & 0xC0) == 0x80) { return continuationByte & 0x3F; } // If we end up here, its not a continuation byte throw Error('Invalid continuation byte'); } function decodeSymbol(strict) { var byte1; var byte2; var byte3; var byte4; var codePoint; if (byteIndex > byteCount) { throw Error('Invalid byte index'); } if (byteIndex == byteCount) { return false; } // Read first byte byte1 = byteArray[byteIndex] & 0xFF; byteIndex++; // 1-byte sequence (no continuation bytes) if ((byte1 & 0x80) == 0) { return byte1; } // 2-byte sequence if ((byte1 & 0xE0) == 0xC0) { byte2 = readContinuationByte(); codePoint = ((byte1 & 0x1F) << 6) | byte2; if (codePoint >= 0x80) { return codePoint; } else { throw Error('Invalid continuation byte'); } } // 3-byte sequence (may include unpaired surrogates) if ((byte1 & 0xF0) == 0xE0) { byte2 = readContinuationByte(); byte3 = readContinuationByte(); codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3; if (codePoint >= 0x0800) { return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD; } else { throw Error('Invalid continuation byte'); } } // 4-byte sequence if ((byte1 & 0xF8) == 0xF0) { byte2 = readContinuationByte(); byte3 = readContinuationByte(); byte4 = readContinuationByte(); codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) | (byte3 << 0x06) | byte4; if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) { return codePoint; } } throw Error('Invalid UTF-8 detected'); } var byteArray; var byteCount; var byteIndex; function utf8decode(byteString, opts) { opts = opts || {}; var strict = false !== opts.strict; byteArray = ucs2decode(byteString); byteCount = byteArray.length; byteIndex = 0; var codePoints = []; var tmp; while ((tmp = decodeSymbol(strict)) !== false) { codePoints.push(tmp); } return ucs2encode(codePoints); } /*--------------------------------------------------------------------------*/ var utf8 = { 'version': '2.1.2', 'encode': utf8encode, 'decode': utf8decode }; // Some AMD build optimizers, like r.js, check for specific condition patterns // like the following: if ( true ) { !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return utf8; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); }	else if (freeExports && !freeExports.nodeType) { if (freeModule) { // in Node.js or RingoJS v0.8.0+ freeModule.exports = utf8; } else { // in Narwhal or RingoJS v0.7.0- var object = {}; var hasOwnProperty = object.hasOwnProperty; for (var key in utf8) { hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]); } } } else { // in Rhino or a web browser root.utf8 = utf8; } }(this)); /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)(module), (function() { return this; }()))) /***/ }), /* 24 */ /***/ (function(module, exports) { module.exports = function(module) { if(!module.webpackPolyfill) { module.deprecate = function() {}; module.paths = []; // module.parent = undefined by default module.children = []; module.webpackPolyfill = 1; } return module; } /***/ }), /* 25 */ /***/ (function(module, exports) { /* * base64-arraybuffer * https://github.com/niklasvh/base64-arraybuffer * * Copyright (c) 2012 Niklas von Hertzen * Licensed under the MIT license. */ (function(){ "use strict"; var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // Use a lookup table to find the index. var lookup = new Uint8Array(256); for (var i = 0; i < chars.length; i++) { lookup[chars.charCodeAt(i)] = i; } exports.encode = function(arraybuffer) { var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = ""; for (i = 0; i < len; i+=3) { base64 += chars[bytes[i] >> 2]; base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)]; base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)]; base64 += chars[bytes[i + 2] & 63]; } if ((len % 3) === 2) { base64 = base64.substring(0, base64.length - 1) + "="; } else if (len % 3 === 1) { base64 = base64.substring(0, base64.length - 2) + "=="; } return base64; }; exports.decode = function(base64) { var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4; if (base64[base64.length - 1] === "=") { bufferLength--; if (base64[base64.length - 2] === "=") { bufferLength--; } } var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer); for (i = 0; i < len; i+=4) { encoded1 = lookup[base64.charCodeAt(i)]; encoded2 = lookup[base64.charCodeAt(i+1)]; encoded3 = lookup[base64.charCodeAt(i+2)]; encoded4 = lookup[base64.charCodeAt(i+3)]; bytes[p++] = (encoded1 << 2) | (encoded2 >> 4); bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2); bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63); } return arraybuffer; }; })(); /***/ }), /* 26 */ /***/ (function(module, exports) { /* WEBPACK VAR INJECTION */(function(global) {/** * Create a blob builder even when vendor prefixes exist */ var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder; /** * Check if Blob constructor is supported */ var blobSupported = (function() { try { var a = new Blob(['hi']); return a.size === 2; } catch(e) { return false; } })(); /** * Check if Blob constructor supports ArrayBufferViews * Fails in Safari 6, so we need to map to ArrayBuffers there. */ var blobSupportsArrayBufferView = blobSupported && (function() { try { var b = new Blob([new Uint8Array([1,2])]); return b.size === 2; } catch(e) { return false; } })(); /** * Check if BlobBuilder is supported */ var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob; /** * Helper function that maps ArrayBufferViews to ArrayBuffers * Used by BlobBuilder constructor and old browsers that didn't * support it in the Blob constructor. */ function mapArrayBufferViews(ary) { for (var i = 0; i < ary.length; i++) { var chunk = ary[i]; if (chunk.buffer instanceof ArrayBuffer) { var buf = chunk.buffer; // if this is a subarray, make a copy so we only // include the subarray region from the underlying buffer if (chunk.byteLength !== buf.byteLength) { var copy = new Uint8Array(chunk.byteLength); copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength)); buf = copy.buffer; } ary[i] = buf; } } } function BlobBuilderConstructor(ary, options) { options = options || {}; var bb = new BlobBuilder(); mapArrayBufferViews(ary); for (var i = 0; i < ary.length; i++) { bb.append(ary[i]); } return (options.type) ? bb.getBlob(options.type) : bb.getBlob(); }; function BlobConstructor(ary, options) { mapArrayBufferViews(ary); return new Blob(ary, options || {}); }; module.exports = (function() { if (blobSupported) { return blobSupportsArrayBufferView ? global.Blob : BlobConstructor; } else if (blobBuilderSupported) { return BlobBuilderConstructor; } else { return undefined; } })(); /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 27 */ /***/ (function(module, exports) { /** * Compiles a querystring * Returns string representation of the object * * @param {Object} * @api private */ exports.encode = function (obj) { var str = ''; for (var i in obj) { if (obj.hasOwnProperty(i)) { if (str.length) str += '&'; str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]); } } return str; }; /** * Parses a simple querystring into an object * * @param {String} qs * @api private */ exports.decode = function(qs){ var qry = {}; var pairs = qs.split('&'); for (var i = 0, l = pairs.length; i < l; i++) { var pair = pairs[i].split('='); qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]); } return qry; }; /***/ }), /* 28 */ /***/ (function(module, exports) { module.exports = function(a, b){ var fn = function(){}; fn.prototype = b.prototype; a.prototype = new fn; a.prototype.constructor = a; }; /***/ }), /* 29 */ /***/ (function(module, exports) { 'use strict'; var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('') , length = 64 , map = {} , seed = 0 , i = 0 , prev; /** * Return a string representing the specified number. * * @param {Number} num The number to convert. * @returns {String} The string representation of the number. * @api public */ function encode(num) { var encoded = ''; do { encoded = alphabet[num % length] + encoded; num = Math.floor(num / length); } while (num > 0); return encoded; } /** * Return the integer value specified by the given string. * * @param {String} str The string to convert. * @returns {Number} The integer value represented by the string. * @api public */ function decode(str) { var decoded = 0; for (i = 0; i < str.length; i++) { decoded = decoded * length + map[str.charAt(i)]; } return decoded; } /** * Yeast: A tiny growing id generator. * * @returns {String} A unique id. * @api public */ function yeast() { var now = encode(+new Date()); if (now !== prev) return seed = 0, prev = now; return now +'.'+ encode(seed++); } // // Map each character to its index. // for (; i < length; i++) map[alphabet[i]] = i; // // Expose the `yeast`, `encode` and `decode` functions. // yeast.encode = encode; yeast.decode = decode; module.exports = yeast; /***/ }), /* 30 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) { /** * Module requirements. */ var Polling = __webpack_require__(16); var inherit = __webpack_require__(28); /** * Module exports. */ module.exports = JSONPPolling; /** * Cached regular expressions. */ var rNewline = /\n/g; var rEscapedNewline = /\\n/g; /** * Global JSONP callbacks. */ var callbacks; /** * Noop. */ function empty () { } /** * JSONP Polling constructor. * * @param {Object} opts. * @api public */ function JSONPPolling (opts) { Polling.call(this, opts); this.query = this.query || {}; // define global callbacks array if not present // we do this here (lazily) to avoid unneeded global pollution if (!callbacks) { // we need to consider multiple engines in the same page if (!global.___eio) global.___eio = []; callbacks = global.___eio; } // callback identifier this.index = callbacks.length; // add callback to jsonp global var self = this; callbacks.push(function (msg) { self.onData(msg); }); // append to query string this.query.j = this.index; // prevent spurious errors from being emitted when the window is unloaded if (global.document && global.addEventListener) { global.addEventListener('beforeunload', function () { if (self.script) self.script.onerror = empty; }, false); } } /** * Inherits from Polling. */ inherit(JSONPPolling, Polling); /* * JSONP only supports binary as base64 encoded strings */ JSONPPolling.prototype.supportsBinary = false; /** * Closes the socket. * * @api private */ JSONPPolling.prototype.doClose = function () { if (this.script) { this.script.parentNode.removeChild(this.script); this.script = null; } if (this.form) { this.form.parentNode.removeChild(this.form); this.form = null; this.iframe = null; } Polling.prototype.doClose.call(this); }; /** * Starts a poll cycle. * * @api private */ JSONPPolling.prototype.doPoll = function () { var self = this; var script = document.createElement('script'); if (this.script) { this.script.parentNode.removeChild(this.script); this.script = null; } script.async = true; script.src = this.uri(); script.onerror = function (e) { self.onError('jsonp poll error', e); }; var insertAt = document.getElementsByTagName('script')[0]; if (insertAt) { insertAt.parentNode.insertBefore(script, insertAt); } else { (document.head || document.body).appendChild(script); } this.script = script; var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent); if (isUAgecko) { setTimeout(function () { var iframe = document.createElement('iframe'); document.body.appendChild(iframe); document.body.removeChild(iframe); }, 100); } }; /** * Writes with a hidden iframe. * * @param {String} data to send * @param {Function} called upon flush. * @api private */ JSONPPolling.prototype.doWrite = function (data, fn) { var self = this; if (!this.form) { var form = document.createElement('form'); var area = document.createElement('textarea'); var id = this.iframeId = 'eio_iframe_' + this.index; var iframe; form.className = 'socketio'; form.style.position = 'absolute'; form.style.top = '-1000px'; form.style.left = '-1000px'; form.target = id; form.method = 'POST'; form.setAttribute('accept-charset', 'utf-8'); area.name = 'd'; form.appendChild(area); document.body.appendChild(form); this.form = form; this.area = area; } this.form.action = this.uri(); function complete () { initIframe(); fn(); } function initIframe () { if (self.iframe) { try { self.form.removeChild(self.iframe); } catch (e) { self.onError('jsonp polling iframe removal error', e); } } try { // ie6 dynamic iframes with target="" support (thanks Chris Lambacher) var html = '<iframe src="javascript:0" name="' + self.iframeId + '">'; iframe = document.createElement(html); } catch (e) { iframe = document.createElement('iframe'); iframe.name = self.iframeId; iframe.src = 'javascript:0'; } iframe.id = self.iframeId; self.form.appendChild(iframe); self.iframe = iframe; } initIframe(); // escape \n to prevent it from being converted into \r\n by some UAs // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side data = data.replace(rEscapedNewline, '\\\n'); this.area.value = data.replace(rNewline, '\\n'); try { this.form.submit(); } catch (e) {} if (this.iframe.attachEvent) { this.iframe.onreadystatechange = function () { if (self.iframe.readyState === 'complete') { complete(); } }; } else { this.iframe.onload = complete; } }; /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 31 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {/** * Module dependencies. */ var Transport = __webpack_require__(17); var parser = __webpack_require__(18); var parseqs = __webpack_require__(27); var inherit = __webpack_require__(28); var yeast = __webpack_require__(29); var debug = __webpack_require__(3)('engine.io-client:websocket'); var BrowserWebSocket = global.WebSocket || global.MozWebSocket; var NodeWebSocket; if (typeof window === 'undefined') { try { NodeWebSocket = __webpack_require__(32); } catch (e) { } } /** * Get either the `WebSocket` or `MozWebSocket` globals * in the browser or try to resolve WebSocket-compatible * interface exposed by `ws` for Node-like environment. */ var WebSocket = BrowserWebSocket; if (!WebSocket && typeof window === 'undefined') { WebSocket = NodeWebSocket; } /** * Module exports. */ module.exports = WS; /** * WebSocket transport constructor. * * @api {Object} connection options * @api public */ function WS (opts) { var forceBase64 = (opts && opts.forceBase64); if (forceBase64) { this.supportsBinary = false; } this.perMessageDeflate = opts.perMessageDeflate; this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode; this.protocols = opts.protocols; if (!this.usingBrowserWebSocket) { WebSocket = NodeWebSocket; } Transport.call(this, opts); } /** * Inherits from Transport. */ inherit(WS, Transport); /** * Transport name. * * @api public */ WS.prototype.name = 'websocket'; /* * WebSockets support binary */ WS.prototype.supportsBinary = true; /** * Opens socket. * * @api private */ WS.prototype.doOpen = function () { if (!this.check()) { // let probe timeout return; } var uri = this.uri(); var protocols = this.protocols; var opts = { agent: this.agent, perMessageDeflate: this.perMessageDeflate }; // SSL options for Node.js client opts.pfx = this.pfx; opts.key = this.key; opts.passphrase = this.passphrase; opts.cert = this.cert; opts.ca = this.ca; opts.ciphers = this.ciphers; opts.rejectUnauthorized = this.rejectUnauthorized; if (this.extraHeaders) { opts.headers = this.extraHeaders; } if (this.localAddress) { opts.localAddress = this.localAddress; } try { this.ws = this.usingBrowserWebSocket ? (protocols ? new WebSocket(uri, protocols) : new WebSocket(uri)) : new WebSocket(uri, protocols, opts); } catch (err) { return this.emit('error', err); } if (this.ws.binaryType === undefined) { this.supportsBinary = false; } if (this.ws.supports && this.ws.supports.binary) { this.supportsBinary = true; this.ws.binaryType = 'nodebuffer'; } else { this.ws.binaryType = 'arraybuffer'; } this.addEventListeners(); }; /** * Adds event listeners to the socket * * @api private */ WS.prototype.addEventListeners = function () { var self = this; this.ws.onopen = function () { self.onOpen(); }; this.ws.onclose = function () { self.onClose(); }; this.ws.onmessage = function (ev) { self.onData(ev.data); }; this.ws.onerror = function (e) { self.onError('websocket error', e); }; }; /** * Writes data to socket. * * @param {Array} array of packets. * @api private */ WS.prototype.write = function (packets) { var self = this; this.writable = false; // encodePacket efficient as it uses WS framing // no need for encodePayload var total = packets.length; for (var i = 0, l = total; i < l; i++) { (function (packet) { parser.encodePacket(packet, self.supportsBinary, function (data) { if (!self.usingBrowserWebSocket) { // always create a new object (GH-437) var opts = {}; if (packet.options) { opts.compress = packet.options.compress; } if (self.perMessageDeflate) { var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length; if (len < self.perMessageDeflate.threshold) { opts.compress = false; } } } // Sometimes the websocket has already been closed but the browser didn't // have a chance of informing us about it yet, in that case send will // throw an error try { if (self.usingBrowserWebSocket) { // TypeError is thrown when passing the second argument on Safari self.ws.send(data); } else { self.ws.send(data, opts); } } catch (e) { } --total || done(); }); })(packets[i]); } function done () { self.emit('flush'); // fake drain // defer to next tick to allow Socket to clear writeBuffer setTimeout(function () { self.writable = true; self.emit('drain'); }, 0); } }; /** * Called upon close * * @api private */ WS.prototype.onClose = function () { Transport.prototype.onClose.call(this); }; /** * Closes socket. * * @api private */ WS.prototype.doClose = function () { if (typeof this.ws !== 'undefined') { this.ws.close(); } }; /** * Generates uri for connection. * * @api private */ WS.prototype.uri = function () { var query = this.query || {}; var schema = this.secure ? 'wss' : 'ws'; var port = ''; // avoid port if default for schema if (this.port && (('wss' === schema && Number(this.port) !== 443) || ('ws' === schema && Number(this.port) !== 80))) { port = ':' + this.port; } // append timestamp to URI if (this.timestampRequests) { query[this.timestampParam] = yeast(); } // communicate binary support capabilities if (!this.supportsBinary) { query.b64 = 1; } query = parseqs.encode(query); // prepend ? to query if (query.length) { query = '?' + query; } var ipv6 = this.hostname.indexOf(':') !== -1; return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query; }; /** * Feature detection for WebSocket. * * @return {Boolean} whether this transport is available. * @api public */ WS.prototype.check = function () { return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name); }; /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 32 */ /***/ (function(module, exports) { /* (ignored) */ /***/ }), /* 33 */ /***/ (function(module, exports) { var indexOf = [].indexOf; module.exports = function(arr, obj){ if (indexOf) return arr.indexOf(obj); for (var i = 0; i < arr.length; ++i) { if (arr[i] === obj) return i; } return -1; }; /***/ }), /* 34 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /** * Module dependencies. */ var parser = __webpack_require__(4); var Emitter = __webpack_require__(5); var toArray = __webpack_require__(35); var on = __webpack_require__(36); var bind = __webpack_require__(37); var debug = __webpack_require__(3)('socket.io-client:socket'); var parseqs = __webpack_require__(27); var hasBin = __webpack_require__(20); /** * Module exports. */ module.exports = exports = Socket; /** * Internal events (blacklisted). * These events can't be emitted by the user. * * @api private */ var events = { connect: 1, connect_error: 1, connect_timeout: 1, connecting: 1, disconnect: 1, error: 1, reconnect: 1, reconnect_attempt: 1, reconnect_failed: 1, reconnect_error: 1, reconnecting: 1, ping: 1, pong: 1 }; /** * Shortcut to `Emitter#emit`. */ var emit = Emitter.prototype.emit; /** * `Socket` constructor. * * @api public */ function Socket(io, nsp, opts) { this.io = io; this.nsp = nsp; this.json = this; // compat this.ids = 0; this.acks = {}; this.receiveBuffer = []; this.sendBuffer = []; this.connected = false; this.disconnected = true; this.flags = {}; if (opts && opts.query) { this.query = opts.query; } if (this.io.autoConnect) this.open(); } /** * Mix in `Emitter`. */ Emitter(Socket.prototype); /** * Subscribe to open, close and packet events * * @api private */ Socket.prototype.subEvents = function () { if (this.subs) return; var io = this.io; this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))]; }; /** * "Opens" the socket. * * @api public */ Socket.prototype.open = Socket.prototype.connect = function () { if (this.connected) return this; this.subEvents(); this.io.open(); // ensure open if ('open' === this.io.readyState) this.onopen(); this.emit('connecting'); return this; }; /** * Sends a `message` event. * * @return {Socket} self * @api public */ Socket.prototype.send = function () { var args = toArray(arguments); args.unshift('message'); this.emit.apply(this, args); return this; }; /** * Override `emit`. * If the event is in `events`, it's emitted normally. * * @param {String} event name * @return {Socket} self * @api public */ Socket.prototype.emit = function (ev) { if (events.hasOwnProperty(ev)) { emit.apply(this, arguments); return this; } var args = toArray(arguments); var packet = { type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT, data: args }; packet.options = {}; packet.options.compress = !this.flags || false !== this.flags.compress; // event ack callback if ('function' === typeof args[args.length - 1]) { this.acks[this.ids] = args.pop(); packet.id = this.ids++; } if (this.connected) { this.packet(packet); } else { this.sendBuffer.push(packet); } this.flags = {}; return this; }; /** * Sends a packet. * * @param {Object} packet * @api private */ Socket.prototype.packet = function (packet) { packet.nsp = this.nsp; this.io.packet(packet); }; /** * Called upon engine `open`. * * @api private */ Socket.prototype.onopen = function () { // write connect packet if necessary if ('/' !== this.nsp) { if (this.query) { var query = _typeof(this.query) === 'object' ? parseqs.encode(this.query) : this.query; this.packet({ type: parser.CONNECT, query: query }); } else { this.packet({ type: parser.CONNECT }); } } }; /** * Called upon engine `close`. * * @param {String} reason * @api private */ Socket.prototype.onclose = function (reason) { this.connected = false; this.disconnected = true; delete this.id; this.emit('disconnect', reason); }; /** * Called with socket packet. * * @param {Object} packet * @api private */ Socket.prototype.onpacket = function (packet) { var sameNamespace = packet.nsp === this.nsp; var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/'; if (!sameNamespace && !rootNamespaceError) return; switch (packet.type) { case parser.CONNECT: this.onconnect(); break; case parser.EVENT: this.onevent(packet); break; case parser.BINARY_EVENT: this.onevent(packet); break; case parser.ACK: this.onack(packet); break; case parser.BINARY_ACK: this.onack(packet); break; case parser.DISCONNECT: this.ondisconnect(); break; case parser.ERROR: this.emit('error', packet.data); break; } }; /** * Called upon a server event. * * @param {Object} packet * @api private */ Socket.prototype.onevent = function (packet) { var args = packet.data || []; if (null != packet.id) { args.push(this.ack(packet.id)); } if (this.connected) { emit.apply(this, args); } else { this.receiveBuffer.push(args); } }; /** * Produces an ack callback to emit with an event. * * @api private */ Socket.prototype.ack = function (id) { var self = this; var sent = false; return function () { // prevent double callbacks if (sent) return; sent = true; var args = toArray(arguments); self.packet({ type: hasBin(args) ? parser.BINARY_ACK : parser.ACK, id: id, data: args }); }; }; /** * Called upon a server acknowlegement. * * @param {Object} packet * @api private */ Socket.prototype.onack = function (packet) { var ack = this.acks[packet.id]; if ('function' === typeof ack) { ack.apply(this, packet.data); delete this.acks[packet.id]; } else {} }; /** * Called upon server connect. * * @api private */ Socket.prototype.onconnect = function () { this.connected = true; this.disconnected = false; this.emit('connect'); this.emitBuffered(); }; /** * Emit buffered events (received and emitted). * * @api private */ Socket.prototype.emitBuffered = function () { var i; for (i = 0; i < this.receiveBuffer.length; i++) { emit.apply(this, this.receiveBuffer[i]); } this.receiveBuffer = []; for (i = 0; i < this.sendBuffer.length; i++) { this.packet(this.sendBuffer[i]); } this.sendBuffer = []; }; /** * Called upon server disconnect. * * @api private */ Socket.prototype.ondisconnect = function () { this.destroy(); this.onclose('io server disconnect'); }; /** * Called upon forced client/server side disconnections, * this method ensures the manager stops tracking us and * that reconnections don't get triggered for this. * * @api private. */ Socket.prototype.destroy = function () { if (this.subs) { // clean subscriptions to avoid reconnections for (var i = 0; i < this.subs.length; i++) { this.subs[i].destroy(); } this.subs = null; } this.io.destroy(this); }; /** * Disconnects the socket manually. * * @return {Socket} self * @api public */ Socket.prototype.close = Socket.prototype.disconnect = function () { if (this.connected) { this.packet({ type: parser.DISCONNECT }); } // remove socket from pool this.destroy(); if (this.connected) { // fire events this.onclose('io client disconnect'); } return this; }; /** * Sets the compress flag. * * @param {Boolean} if `true`, compresses the sending data * @return {Socket} self * @api public */ Socket.prototype.compress = function (compress) { this.flags.compress = compress; return this; }; /** * Sets the binary flag * * @param {Boolean} whether the emitted data contains binary * @return {Socket} self * @api public */ Socket.prototype.binary = function (binary) { this.flags.binary = binary; return this; }; /***/ }), /* 35 */ /***/ (function(module, exports) { module.exports = toArray function toArray(list, index) { var array = [] index = index || 0 for (var i = index || 0; i < list.length; i++) { array[i - index] = list[i] } return array } /***/ }), /* 36 */ /***/ (function(module, exports) { "use strict"; /** * Module exports. */ module.exports = on; /** * Helper for subscriptions. * * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter` * @param {String} event name * @param {Function} callback * @api public */ function on(obj, ev, fn) { obj.on(ev, fn); return { destroy: function destroy() { obj.removeListener(ev, fn); } }; } /***/ }), /* 37 */ /***/ (function(module, exports) { /** * Slice reference. */ var slice = [].slice; /** * Bind `obj` to `fn`. * * @param {Object} obj * @param {Function|String} fn or string * @return {Function} * @api public */ module.exports = function(obj, fn){ if ('string' == typeof fn) fn = obj[fn]; if ('function' != typeof fn) throw new Error('bind() requires a function'); var args = slice.call(arguments, 2); return function(){ return fn.apply(obj, args.concat(slice.call(arguments))); } }; /***/ }), /* 38 */ /***/ (function(module, exports) { /** * Expose `Backoff`. */ module.exports = Backoff; /** * Initialize backoff timer with `opts`. * * - `min` initial timeout in milliseconds [100] * - `max` max timeout [10000] * - `jitter` [0] * - `factor` [2] * * @param {Object} opts * @api public */ function Backoff(opts) { opts = opts || {}; this.ms = opts.min || 100; this.max = opts.max || 10000; this.factor = opts.factor || 2; this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0; this.attempts = 0; } /** * Return the backoff duration. * * @return {Number} * @api public */ Backoff.prototype.duration = function(){ var ms = this.ms * Math.pow(this.factor, this.attempts++); if (this.jitter) { var rand = Math.random(); var deviation = Math.floor(rand * this.jitter * ms); ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation; } return Math.min(ms, this.max) | 0; }; /** * Reset the number of attempts. * * @api public */ Backoff.prototype.reset = function(){ this.attempts = 0; }; /** * Set the minimum duration * * @api public */ Backoff.prototype.setMin = function(min){ this.ms = min; }; /** * Set the maximum duration * * @api public */ Backoff.prototype.setMax = function(max){ this.max = max; }; /** * Set the jitter * * @api public */ Backoff.prototype.setJitter = function(jitter){ this.jitter = jitter; }; /***/ }) /******/ ]) }); ; // WEBPACK FOOTER // // socket.io.slim.js",
" // The module cache var installedModules = {}; // The require function function __webpack_require__(moduleId) { // Check if module is in cache if(installedModules[moduleId]) return installedModules[moduleId].exports; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = { exports: {}, id: moduleId, loaded: false }; // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.loaded = true; // Return the exports of the module return module.exports; } // expose the modules object (__webpack_modules__) __webpack_require__.m = modules; // expose the module cache __webpack_require__.c = installedModules; // __webpack_public_path__ __webpack_require__.p = ""; // Load entry module and return exports return __webpack_require__(0); // WEBPACK FOOTER // // webpack/bootstrap 82d2f1547c0a2d88046d",
" /** * Module dependencies. */ var url = require('./url'); var parser = require('socket.io-parser'); var Manager = require('./manager'); var debug = require('debug')('socket.io-client'); /** * Module exports. */ module.exports = exports = lookup; /** * Managers cache. */ var cache = exports.managers = {}; /** * Looks up an existing `Manager` for multiplexing. * If the user summons: * * `io('http://localhost/a');` * `io('http://localhost/b');` * * We reuse the existing instance based on same scheme/port/host, * and we initialize sockets for each namespace. * * @api public */ function lookup (uri, opts) { if (typeof uri === 'object') { opts = uri; uri = undefined; } opts = opts || {}; var parsed = url(uri); var source = parsed.source; var id = parsed.id; var path = parsed.path; var sameNamespace = cache[id] && path in cache[id].nsps; var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace; var io; if (newConnection) { io = Manager(source, opts); } else { if (!cache[id]) { cache[id] = Manager(source, opts); } io = cache[id]; } if (parsed.query && !opts.query) { opts.query = parsed.query; } return io.socket(parsed.path, opts); } /** * Protocol version. * * @api public */ exports.protocol = parser.protocol; /** * `connect`. * * @param {String} uri * @api public */ exports.connect = lookup; /** * Expose constructors for standalone build. * * @api public */ exports.Manager = require('./manager'); exports.Socket = require('./socket'); // WEBPACK FOOTER // // ./lib/index.js",
" /** * Module dependencies. */ var parseuri = require('parseuri'); var debug = require('debug')('socket.io-client:url'); /** * Module exports. */ module.exports = url; /** * URL parser. * * @param {String} url * @param {Object} An object meant to mimic window.location. * Defaults to window.location. * @api public */ function url (uri, loc) { var obj = uri; // default to window.location loc = loc || global.location; if (null == uri) uri = loc.protocol + '//' + loc.host; // relative path support if ('string' === typeof uri) { if ('/' === uri.charAt(0)) { if ('/' === uri.charAt(1)) { uri = loc.protocol + uri; } else { uri = loc.host + uri; } } if (!/^(https?|wss?):\/\//.test(uri)) { if ('undefined' !== typeof loc) { uri = loc.protocol + '//' + uri; } else { uri = 'https://' + uri; } } // parse obj = parseuri(uri); } // make sure we treat `localhost:80` and `localhost` equally if (!obj.port) { if (/^(http|ws)$/.test(obj.protocol)) { obj.port = '80'; } else if (/^(http|ws)s$/.test(obj.protocol)) { obj.port = '443'; } } obj.path = obj.path || '/'; var ipv6 = obj.host.indexOf(':') !== -1; var host = ipv6 ? '[' + obj.host + ']' : obj.host; // define unique id obj.id = obj.protocol + '://' + host + ':' + obj.port; // define href obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port)); return obj; } // WEBPACK FOOTER // // ./lib/url.js",
"/** * Parses an URI * * @author Steven Levithan <stevenlevithan.com> (MIT license) * @api private */ var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/; var parts = [ 'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor' ]; module.exports = function parseuri(str) { var src = str, b = str.indexOf('['), e = str.indexOf(']'); if (b != -1 && e != -1) { str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length); } var m = re.exec(str || ''), uri = {}, i = 14; while (i--) { uri[parts[i]] = m[i] || ''; } if (b != -1 && e != -1) { uri.source = src; uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':'); uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':'); uri.ipv6uri = true; } return uri; }; ////////////////// // WEBPACK FOOTER // ./~/parseuri/index.js // module id = 2 // module chunks = 0",
" module.exports = function () { return function () {}; }; // WEBPACK FOOTER // // ./support/noop.js",
" /** * Module dependencies. */ var debug = require('debug')('socket.io-parser'); var Emitter = require('component-emitter'); var binary = require('./binary'); var isArray = require('isarray'); var isBuf = require('./is-buffer'); /** * Protocol version. * * @api public */ exports.protocol = 4; /** * Packet types. * * @api public */ exports.types = [ 'CONNECT', 'DISCONNECT', 'EVENT', 'ACK', 'ERROR', 'BINARY_EVENT', 'BINARY_ACK' ]; /** * Packet type `connect`. * * @api public */ exports.CONNECT = 0; /** * Packet type `disconnect`. * * @api public */ exports.DISCONNECT = 1; /** * Packet type `event`. * * @api public */ exports.EVENT = 2; /** * Packet type `ack`. * * @api public */ exports.ACK = 3; /** * Packet type `error`. * * @api public */ exports.ERROR = 4; /** * Packet type 'binary event' * * @api public */ exports.BINARY_EVENT = 5; /** * Packet type `binary ack`. For acks with binary arguments. * * @api public */ exports.BINARY_ACK = 6; /** * Encoder constructor. * * @api public */ exports.Encoder = Encoder; /** * Decoder constructor. * * @api public */ exports.Decoder = Decoder; /** * A socket.io Encoder instance * * @api public */ function Encoder() {} var ERROR_PACKET = exports.ERROR + '"encode error"'; /** * Encode a packet as a single string if non-binary, or as a * buffer sequence, depending on packet type. * * @param {Object} obj - packet object * @param {Function} callback - function to handle encodings (likely engine.write) * @return Calls callback with Array of encodings * @api public */ Encoder.prototype.encode = function(obj, callback){ if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) { encodeAsBinary(obj, callback); } else { var encoding = encodeAsString(obj); callback([encoding]); } }; /** * Encode packet as string. * * @param {Object} packet * @return {String} encoded * @api private */ function encodeAsString(obj) { // first is type var str = '' + obj.type; // attachments if we have them if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) { str += obj.attachments + '-'; } // if we have a namespace other than `/` // we append it followed by a comma `,` if (obj.nsp && '/' !== obj.nsp) { str += obj.nsp + ','; } // immediately followed by the id if (null != obj.id) { str += obj.id; } // json data if (null != obj.data) { var payload = tryStringify(obj.data); if (payload !== false) { str += payload; } else { return ERROR_PACKET; } } return str; } function tryStringify(str) { try { return JSON.stringify(str); } catch(e){ return false; } } /** * Encode packet as 'buffer sequence' by removing blobs, and * deconstructing packet into object with placeholders and * a list of buffers. * * @param {Object} packet * @return {Buffer} encoded * @api private */ function encodeAsBinary(obj, callback) { function writeEncoding(bloblessData) { var deconstruction = binary.deconstructPacket(bloblessData); var pack = encodeAsString(deconstruction.packet); var buffers = deconstruction.buffers; buffers.unshift(pack); // add packet info to beginning of data list callback(buffers); // write all the buffers } binary.removeBlobs(obj, writeEncoding); } /** * A socket.io Decoder instance * * @return {Object} decoder * @api public */ function Decoder() { this.reconstructor = null; } /** * Mix in `Emitter` with Decoder. */ Emitter(Decoder.prototype); /** * Decodes an ecoded packet string into packet JSON. * * @param {String} obj - encoded packet * @return {Object} packet * @api public */ Decoder.prototype.add = function(obj) { var packet; if (typeof obj === 'string') { packet = decodeString(obj); if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json this.reconstructor = new BinaryReconstructor(packet); // no attachments, labeled binary but no binary data to follow if (this.reconstructor.reconPack.attachments === 0) { this.emit('decoded', packet); } } else { // non-binary full packet this.emit('decoded', packet); } } else if (isBuf(obj) || obj.base64) { // raw binary data if (!this.reconstructor) { throw new Error('got binary data when not reconstructing a packet'); } else { packet = this.reconstructor.takeBinaryData(obj); if (packet) { // received final buffer this.reconstructor = null; this.emit('decoded', packet); } } } else { throw new Error('Unknown type: ' + obj); } }; /** * Decode a packet String (JSON data) * * @param {String} str * @return {Object} packet * @api private */ function decodeString(str) { var i = 0; // look up type var p = { type: Number(str.charAt(0)) }; if (null == exports.types[p.type]) { return error('unknown packet type ' + p.type); } // look up attachments if type binary if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) { var buf = ''; while (str.charAt(++i) !== '-') { buf += str.charAt(i); if (i == str.length) break; } if (buf != Number(buf) || str.charAt(i) !== '-') { throw new Error('Illegal attachments'); } p.attachments = Number(buf); } // look up namespace (if any) if ('/' === str.charAt(i + 1)) { p.nsp = ''; while (++i) { var c = str.charAt(i); if (',' === c) break; p.nsp += c; if (i === str.length) break; } } else { p.nsp = '/'; } // look up id var next = str.charAt(i + 1); if ('' !== next && Number(next) == next) { p.id = ''; while (++i) { var c = str.charAt(i); if (null == c || Number(c) != c) { --i; break; } p.id += str.charAt(i); if (i === str.length) break; } p.id = Number(p.id); } // look up json data if (str.charAt(++i)) { var payload = tryParse(str.substr(i)); var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload)); if (isPayloadValid) { p.data = payload; } else { return error('invalid payload'); } } return p; } function tryParse(str) { try { return JSON.parse(str); } catch(e){ return false; } } /** * Deallocates a parser's resources * * @api public */ Decoder.prototype.destroy = function() { if (this.reconstructor) { this.reconstructor.finishedReconstruction(); } }; /** * A manager of a binary event's 'buffer sequence'. Should * be constructed whenever a packet of type BINARY_EVENT is * decoded. * * @param {Object} packet * @return {BinaryReconstructor} initialized reconstructor * @api private */ function BinaryReconstructor(packet) { this.reconPack = packet; this.buffers = []; } /** * Method to be called when binary data received from connection * after a BINARY_EVENT packet. * * @param {Buffer | ArrayBuffer} binData - the raw binary data received * @return {null | Object} returns null if more binary data is expected or * a reconstructed packet object if all buffers have been received. * @api private */ BinaryReconstructor.prototype.takeBinaryData = function(binData) { this.buffers.push(binData); if (this.buffers.length === this.reconPack.attachments) { // done with buffer list var packet = binary.reconstructPacket(this.reconPack, this.buffers); this.finishedReconstruction(); return packet; } return null; }; /** * Cleans up binary packet reconstruction variables. * * @api private */ BinaryReconstructor.prototype.finishedReconstruction = function() { this.reconPack = null; this.buffers = []; }; function error(msg) { return { type: exports.ERROR, data: 'parser error: ' + msg }; } ////////////////// // WEBPACK FOOTER // ./~/socket.io-parser/index.js // module id = 4 // module chunks = 0",
" /** * Expose `Emitter`. */ if (typeof module !== 'undefined') { module.exports = Emitter; } /** * Initialize a new `Emitter`. * * @api public */ function Emitter(obj) { if (obj) return mixin(obj); }; /** * Mixin the emitter properties. * * @param {Object} obj * @return {Object} * @api private */ function mixin(obj) { for (var key in Emitter.prototype) { obj[key] = Emitter.prototype[key]; } return obj; } /** * Listen on the given `event` with `fn`. * * @param {String} event * @param {Function} fn * @return {Emitter} * @api public */ Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn){ this._callbacks = this._callbacks || {}; (this._callbacks['$' + event] = this._callbacks['$' + event] || []) .push(fn); return this; }; /** * Adds an `event` listener that will be invoked a single * time then automatically removed. * * @param {String} event * @param {Function} fn * @return {Emitter} * @api public */ Emitter.prototype.once = function(event, fn){ function on() { this.off(event, on); fn.apply(this, arguments); } on.fn = fn; this.on(event, on); return this; }; /** * Remove the given callback for `event` or all * registered callbacks. * * @param {String} event * @param {Function} fn * @return {Emitter} * @api public */ Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn){ this._callbacks = this._callbacks || {}; // all if (0 == arguments.length) { this._callbacks = {}; return this; } // specific event var callbacks = this._callbacks['$' + event]; if (!callbacks) return this; // remove all handlers if (1 == arguments.length) { delete this._callbacks['$' + event]; return this; } // remove specific handler var cb; for (var i = 0; i < callbacks.length; i++) { cb = callbacks[i]; if (cb === fn || cb.fn === fn) { callbacks.splice(i, 1); break; } } return this; }; /** * Emit `event` with the given args. * * @param {String} event * @param {Mixed} ... * @return {Emitter} */ Emitter.prototype.emit = function(event){ this._callbacks = this._callbacks || {}; var args = [].slice.call(arguments, 1) , callbacks = this._callbacks['$' + event]; if (callbacks) { callbacks = callbacks.slice(0); for (var i = 0, len = callbacks.length; i < len; ++i) { callbacks[i].apply(this, args); } } return this; }; /** * Return array of callbacks for `event`. * * @param {String} event * @return {Array} * @api public */ Emitter.prototype.listeners = function(event){ this._callbacks = this._callbacks || {}; return this._callbacks['$' + event] || []; }; /** * Check if this emitter has `event` handlers. * * @param {String} event * @return {Boolean} * @api public */ Emitter.prototype.hasListeners = function(event){ return !! this.listeners(event).length; }; ////////////////// // WEBPACK FOOTER // ./~/component-emitter/index.js // module id = 5 // module chunks = 0",
"/*global Blob,File*/ /** * Module requirements */ var isArray = require('isarray'); var isBuf = require('./is-buffer'); var toString = Object.prototype.toString; var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]'; var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]'; /** * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder. * Anything with blobs or files should be fed through removeBlobs before coming * here. * * @param {Object} packet - socket.io event packet * @return {Object} with deconstructed packet and list of buffers * @api public */ exports.deconstructPacket = function(packet) { var buffers = []; var packetData = packet.data; var pack = packet; pack.data = _deconstructPacket(packetData, buffers); pack.attachments = buffers.length; // number of binary 'attachments' return {packet: pack, buffers: buffers}; }; function _deconstructPacket(data, buffers) { if (!data) return data; if (isBuf(data)) { var placeholder = { _placeholder: true, num: buffers.length }; buffers.push(data); return placeholder; } else if (isArray(data)) { var newData = new Array(data.length); for (var i = 0; i < data.length; i++) { newData[i] = _deconstructPacket(data[i], buffers); } return newData; } else if (typeof data === 'object' && !(data instanceof Date)) { var newData = {}; for (var key in data) { newData[key] = _deconstructPacket(data[key], buffers); } return newData; } return data; } /** * Reconstructs a binary packet from its placeholder packet and buffers * * @param {Object} packet - event packet with placeholders * @param {Array} buffers - binary buffers to put in placeholder positions * @return {Object} reconstructed packet * @api public */ exports.reconstructPacket = function(packet, buffers) { packet.data = _reconstructPacket(packet.data, buffers); packet.attachments = undefined; // no longer useful return packet; }; function _reconstructPacket(data, buffers) { if (!data) return data; if (data && data._placeholder) { return buffers[data.num]; // appropriate buffer (should be natural order anyway) } else if (isArray(data)) { for (var i = 0; i < data.length; i++) { data[i] = _reconstructPacket(data[i], buffers); } } else if (typeof data === 'object') { for (var key in data) { data[key] = _reconstructPacket(data[key], buffers); } } return data; } /** * Asynchronously removes Blobs or Files from data via * FileReader's readAsArrayBuffer method. Used before encoding * data as msgpack. Calls callback with the blobless data. * * @param {Object} data * @param {Function} callback * @api private */ exports.removeBlobs = function(data, callback) { function _removeBlobs(obj, curKey, containingObject) { if (!obj) return obj; // convert any blob if ((withNativeBlob && obj instanceof Blob) || (withNativeFile && obj instanceof File)) { pendingBlobs++; // async filereader var fileReader = new FileReader(); fileReader.onload = function() { // this.result == arraybuffer if (containingObject) { containingObject[curKey] = this.result; } else { bloblessData = this.result; } // if nothing pending its callback time if(! --pendingBlobs) { callback(bloblessData); } }; fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer } else if (isArray(obj)) { // handle array for (var i = 0; i < obj.length; i++) { _removeBlobs(obj[i], i, obj); } } else if (typeof obj === 'object' && !isBuf(obj)) { // and object for (var key in obj) { _removeBlobs(obj[key], key, obj); } } } var pendingBlobs = 0; var bloblessData = data; _removeBlobs(bloblessData); if (!pendingBlobs) { callback(bloblessData); } }; ////////////////// // WEBPACK FOOTER // ./~/socket.io-parser/binary.js // module id = 6 // module chunks = 0",
"var toString = {}.toString; module.exports = Array.isArray || function (arr) { return toString.call(arr) == '[object Array]'; }; ////////////////// // WEBPACK FOOTER // ./~/isarray/index.js // module id = 7 // module chunks = 0",
" module.exports = isBuf; var withNativeBuffer = typeof global.Buffer === 'function' && typeof global.Buffer.isBuffer === 'function'; var withNativeArrayBuffer = typeof global.ArrayBuffer === 'function'; var isView = (function () { if (withNativeArrayBuffer && typeof global.ArrayBuffer.isView === 'function') { return global.ArrayBuffer.isView; } else { return function (obj) { return obj.buffer instanceof global.ArrayBuffer; }; } })(); /** * Returns true if obj is a buffer or an arraybuffer. * * @api private */ function isBuf(obj) { return (withNativeBuffer && global.Buffer.isBuffer(obj)) || (withNativeArrayBuffer && (obj instanceof global.ArrayBuffer || isView(obj))); } ////////////////// // WEBPACK FOOTER // ./~/socket.io-parser/is-buffer.js // module id = 8 // module chunks = 0",
" /** * Module dependencies. */ var eio = require('engine.io-client'); var Socket = require('./socket'); var Emitter = require('component-emitter'); var parser = require('socket.io-parser'); var on = require('./on'); var bind = require('component-bind'); var debug = require('debug')('socket.io-client:manager'); var indexOf = require('indexof'); var Backoff = require('backo2'); /** * IE6+ hasOwnProperty */ var has = Object.prototype.hasOwnProperty; /** * Module exports */ module.exports = Manager; /** * `Manager` constructor. * * @param {String} engine instance or engine uri/opts * @param {Object} options * @api public */ function Manager (uri, opts) { if (!(this instanceof Manager)) return new Manager(uri, opts); if (uri && ('object' === typeof uri)) { opts = uri; uri = undefined; } opts = opts || {}; opts.path = opts.path || '/socket.io'; this.nsps = {}; this.subs = []; this.opts = opts; this.reconnection(opts.reconnection !== false); this.reconnectionAttempts(opts.reconnectionAttempts || Infinity); this.reconnectionDelay(opts.reconnectionDelay || 1000); this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000); this.randomizationFactor(opts.randomizationFactor || 0.5); this.backoff = new Backoff({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }); this.timeout(null == opts.timeout ? 20000 : opts.timeout); this.readyState = 'closed'; this.uri = uri; this.connecting = []; this.lastPing = null; this.encoding = false; this.packetBuffer = []; var _parser = opts.parser || parser; this.encoder = new _parser.Encoder(); this.decoder = new _parser.Decoder(); this.autoConnect = opts.autoConnect !== false; if (this.autoConnect) this.open(); } /** * Propagate given event to sockets and emit on `this` * * @api private */ Manager.prototype.emitAll = function () { this.emit.apply(this, arguments); for (var nsp in this.nsps) { if (has.call(this.nsps, nsp)) { this.nsps[nsp].emit.apply(this.nsps[nsp], arguments); } } }; /** * Update `socket.id` of all sockets * * @api private */ Manager.prototype.updateSocketIds = function () { for (var nsp in this.nsps) { if (has.call(this.nsps, nsp)) { this.nsps[nsp].id = this.generateId(nsp); } } }; /** * generate `socket.id` for the given `nsp` * * @param {String} nsp * @return {String} * @api private */ Manager.prototype.generateId = function (nsp) { return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id; }; /** * Mix in `Emitter`. */ Emitter(Manager.prototype); /** * Sets the `reconnection` config. * * @param {Boolean} true/false if it should automatically reconnect * @return {Manager} self or value * @api public */ Manager.prototype.reconnection = function (v) { if (!arguments.length) return this._reconnection; this._reconnection = !!v; return this; }; /** * Sets the reconnection attempts config. * * @param {Number} max reconnection attempts before giving up * @return {Manager} self or value * @api public */ Manager.prototype.reconnectionAttempts = function (v) { if (!arguments.length) return this._reconnectionAttempts; this._reconnectionAttempts = v; return this; }; /** * Sets the delay between reconnections. * * @param {Number} delay * @return {Manager} self or value * @api public */ Manager.prototype.reconnectionDelay = function (v) { if (!arguments.length) return this._reconnectionDelay; this._reconnectionDelay = v; this.backoff && this.backoff.setMin(v); return this; }; Manager.prototype.randomizationFactor = function (v) { if (!arguments.length) return this._randomizationFactor; this._randomizationFactor = v; this.backoff && this.backoff.setJitter(v); return this; }; /** * Sets the maximum delay between reconnections. * * @param {Number} delay * @return {Manager} self or value * @api public */ Manager.prototype.reconnectionDelayMax = function (v) { if (!arguments.length) return this._reconnectionDelayMax; this._reconnectionDelayMax = v; this.backoff && this.backoff.setMax(v); return this; }; /** * Sets the connection timeout. `false` to disable * * @return {Manager} self or value * @api public */ Manager.prototype.timeout = function (v) { if (!arguments.length) return this._timeout; this._timeout = v; return this; }; /** * Starts trying to reconnect if reconnection is enabled and we have not * started reconnecting yet * * @api private */ Manager.prototype.maybeReconnectOnOpen = function () { // Only try to reconnect if it's the first time we're connecting if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) { // keeps reconnection from firing twice for the same reconnection loop this.reconnect(); } }; /** * Sets the current transport `socket`. * * @param {Function} optional, callback * @return {Manager} self * @api public */ Manager.prototype.open = Manager.prototype.connect = function (fn, opts) { if (~this.readyState.indexOf('open')) return this; this.engine = eio(this.uri, this.opts); var socket = this.engine; var self = this; this.readyState = 'opening'; this.skipReconnect = false; // emit `open` var openSub = on(socket, 'open', function () { self.onopen(); fn && fn(); }); // emit `connect_error` var errorSub = on(socket, 'error', function (data) { self.cleanup(); self.readyState = 'closed'; self.emitAll('connect_error', data); if (fn) { var err = new Error('Connection error'); err.data = data; fn(err); } else { // Only do this if there is no fn to handle the error self.maybeReconnectOnOpen(); } }); // emit `connect_timeout` if (false !== this._timeout) { var timeout = this._timeout; // set timer var timer = setTimeout(function () { openSub.destroy(); socket.close(); socket.emit('error', 'timeout'); self.emitAll('connect_timeout', timeout); }, timeout); this.subs.push({ destroy: function () { clearTimeout(timer); } }); } this.subs.push(openSub); this.subs.push(errorSub); return this; }; /** * Called upon transport open. * * @api private */ Manager.prototype.onopen = function () { // clear old subs this.cleanup(); // mark as open this.readyState = 'open'; this.emit('open'); // add new subs var socket = this.engine; this.subs.push(on(socket, 'data', bind(this, 'ondata'))); this.subs.push(on(socket, 'ping', bind(this, 'onping'))); this.subs.push(on(socket, 'pong', bind(this, 'onpong'))); this.subs.push(on(socket, 'error', bind(this, 'onerror'))); this.subs.push(on(socket, 'close', bind(this, 'onclose'))); this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded'))); }; /** * Called upon a ping. * * @api private */ Manager.prototype.onping = function () { this.lastPing = new Date(); this.emitAll('ping'); }; /** * Called upon a packet. * * @api private */ Manager.prototype.onpong = function () { this.emitAll('pong', new Date() - this.lastPing); }; /** * Called with data. * * @api private */ Manager.prototype.ondata = function (data) { this.decoder.add(data); }; /** * Called when parser fully decodes a packet. * * @api private */ Manager.prototype.ondecoded = function (packet) { this.emit('packet', packet); }; /** * Called upon socket error. * * @api private */ Manager.prototype.onerror = function (err) { this.emitAll('error', err); }; /** * Creates a new socket for the given `nsp`. * * @return {Socket} * @api public */ Manager.prototype.socket = function (nsp, opts) { var socket = this.nsps[nsp]; if (!socket) { socket = new Socket(this, nsp, opts); this.nsps[nsp] = socket; var self = this; socket.on('connecting', onConnecting); socket.on('connect', function () { socket.id = self.generateId(nsp); }); if (this.autoConnect) { // manually call here since connecting event is fired before listening onConnecting(); } } function onConnecting () { if (!~indexOf(self.connecting, socket)) { self.connecting.push(socket); } } return socket; }; /** * Called upon a socket close. * * @param {Socket} socket */ Manager.prototype.destroy = function (socket) { var index = indexOf(this.connecting, socket); if (~index) this.connecting.splice(index, 1); if (this.connecting.length) return; this.close(); }; /** * Writes a packet. * * @param {Object} packet * @api private */ Manager.prototype.packet = function (packet) { var self = this; if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query; if (!self.encoding) { // encode, then write to engine with result self.encoding = true; this.encoder.encode(packet, function (encodedPackets) { for (var i = 0; i < encodedPackets.length; i++) { self.engine.write(encodedPackets[i], packet.options); } self.encoding = false; self.processPacketQueue(); }); } else { // add packet to the queue self.packetBuffer.push(packet); } }; /** * If packet buffer is non-empty, begins encoding the * next packet in line. * * @api private */ Manager.prototype.processPacketQueue = function () { if (this.packetBuffer.length > 0 && !this.encoding) { var pack = this.packetBuffer.shift(); this.packet(pack); } }; /** * Clean up transport subscriptions and packet buffer. * * @api private */ Manager.prototype.cleanup = function () { var subsLength = this.subs.length; for (var i = 0; i < subsLength; i++) { var sub = this.subs.shift(); sub.destroy(); } this.packetBuffer = []; this.encoding = false; this.lastPing = null; this.decoder.destroy(); }; /** * Close the current socket. * * @api private */ Manager.prototype.close = Manager.prototype.disconnect = function () { this.skipReconnect = true; this.reconnecting = false; if ('opening' === this.readyState) { // `onclose` will not fire because // an open event never happened this.cleanup(); } this.backoff.reset(); this.readyState = 'closed'; if (this.engine) this.engine.close(); }; /** * Called upon engine close. * * @api private */ Manager.prototype.onclose = function (reason) { this.cleanup(); this.backoff.reset(); this.readyState = 'closed'; this.emit('close', reason); if (this._reconnection && !this.skipReconnect) { this.reconnect(); } }; /** * Attempt a reconnection. * * @api private */ Manager.prototype.reconnect = function () { if (this.reconnecting || this.skipReconnect) return this; var self = this; if (this.backoff.attempts >= this._reconnectionAttempts) { this.backoff.reset(); this.emitAll('reconnect_failed'); this.reconnecting = false; } else { var delay = this.backoff.duration(); this.reconnecting = true; var timer = setTimeout(function () { if (self.skipReconnect) return; self.emitAll('reconnect_attempt', self.backoff.attempts); self.emitAll('reconnecting', self.backoff.attempts); // check again for the case socket closed in above events if (self.skipReconnect) return; self.open(function (err) { if (err) { self.reconnecting = false; self.reconnect(); self.emitAll('reconnect_error', err.data); } else { self.onreconnect(); } }); }, delay); this.subs.push({ destroy: function () { clearTimeout(timer); } }); } }; /** * Called upon successful reconnect. * * @api private */ Manager.prototype.onreconnect = function () { var attempt = this.backoff.attempts; this.reconnecting = false; this.backoff.reset(); this.updateSocketIds(); this.emitAll('reconnect', attempt); }; // WEBPACK FOOTER // // ./lib/manager.js",
" module.exports = require('./socket'); /** * Exports parser * * @api public * */ module.exports.parser = require('engine.io-parser'); ////////////////// // WEBPACK FOOTER // ./~/engine.io-client/lib/index.js // module id = 10 // module chunks = 0",
"/** * Module dependencies. */ var transports = require('./transports/index'); var Emitter = require('component-emitter'); var debug = require('debug')('engine.io-client:socket'); var index = require('indexof'); var parser = require('engine.io-parser'); var parseuri = require('parseuri'); var parseqs = require('parseqs'); /** * Module exports. */ module.exports = Socket; /** * Socket constructor. * * @param {String|Object} uri or options * @param {Object} options * @api public */ function Socket (uri, opts) { if (!(this instanceof Socket)) return new Socket(uri, opts); opts = opts || {}; if (uri && 'object' === typeof uri) { opts = uri; uri = null; } if (uri) { uri = parseuri(uri); opts.hostname = uri.host; opts.secure = uri.protocol === 'https' || uri.protocol === 'wss'; opts.port = uri.port; if (uri.query) opts.query = uri.query; } else if (opts.host) { opts.hostname = parseuri(opts.host).host; } this.secure = null != opts.secure ? opts.secure : (global.location && 'https:' === location.protocol); if (opts.hostname && !opts.port) { // if no port is specified manually, use the protocol default opts.port = this.secure ? '443' : '80'; } this.agent = opts.agent || false; this.hostname = opts.hostname || (global.location ? location.hostname : 'localhost'); this.port = opts.port || (global.location && location.port ? location.port : (this.secure ? 443 : 80)); this.query = opts.query || {}; if ('string' === typeof this.query) this.query = parseqs.decode(this.query); this.upgrade = false !== opts.upgrade; this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/'; this.forceJSONP = !!opts.forceJSONP; this.jsonp = false !== opts.jsonp; this.forceBase64 = !!opts.forceBase64; this.enablesXDR = !!opts.enablesXDR; this.timestampParam = opts.timestampParam || 't'; this.timestampRequests = opts.timestampRequests; this.transports = opts.transports || ['polling', 'websocket']; this.transportOptions = opts.transportOptions || {}; this.readyState = ''; this.writeBuffer = []; this.prevBufferLen = 0; this.policyPort = opts.policyPort || 843; this.rememberUpgrade = opts.rememberUpgrade || false; this.binaryType = null; this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades; this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false; if (true === this.perMessageDeflate) this.perMessageDeflate = {}; if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) { this.perMessageDeflate.threshold = 1024; } // SSL options for Node.js client this.pfx = opts.pfx || null; this.key = opts.key || null; this.passphrase = opts.passphrase || null; this.cert = opts.cert || null; this.ca = opts.ca || null; this.ciphers = opts.ciphers || null; this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized; this.forceNode = !!opts.forceNode; // other options for Node.js client var freeGlobal = typeof global === 'object' && global; if (freeGlobal.global === freeGlobal) { if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) { this.extraHeaders = opts.extraHeaders; } if (opts.localAddress) { this.localAddress = opts.localAddress; } } // set on handshake this.id = null; this.upgrades = null; this.pingInterval = null; this.pingTimeout = null; // set on heartbeat this.pingIntervalTimer = null; this.pingTimeoutTimer = null; this.open(); } Socket.priorWebsocketSuccess = false; /** * Mix in `Emitter`. */ Emitter(Socket.prototype); /** * Protocol version. * * @api public */ Socket.protocol = parser.protocol; // this is an int /** * Expose deps for legacy compatibility * and standalone browser access. */ Socket.Socket = Socket; Socket.Transport = require('./transport'); Socket.transports = require('./transports/index'); Socket.parser = require('engine.io-parser'); /** * Creates transport of the given type. * * @param {String} transport name * @return {Transport} * @api private */ Socket.prototype.createTransport = function (name) { var query = clone(this.query); // append engine.io protocol identifier query.EIO = parser.protocol; // transport name query.transport = name; // per-transport options var options = this.transportOptions[name] || {}; // session id if we already have one if (this.id) query.sid = this.id; var transport = new transports[name]({ query: query, socket: this, agent: options.agent || this.agent, hostname: options.hostname || this.hostname, port: options.port || this.port, secure: options.secure || this.secure, path: options.path || this.path, forceJSONP: options.forceJSONP || this.forceJSONP, jsonp: options.jsonp || this.jsonp, forceBase64: options.forceBase64 || this.forceBase64, enablesXDR: options.enablesXDR || this.enablesXDR, timestampRequests: options.timestampRequests || this.timestampRequests, timestampParam: options.timestampParam || this.timestampParam, policyPort: options.policyPort || this.policyPort, pfx: options.pfx || this.pfx, key: options.key || this.key, passphrase: options.passphrase || this.passphrase, cert: options.cert || this.cert, ca: options.ca || this.ca, ciphers: options.ciphers || this.ciphers, rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized, perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate, extraHeaders: options.extraHeaders || this.extraHeaders, forceNode: options.forceNode || this.forceNode, localAddress: options.localAddress || this.localAddress, requestTimeout: options.requestTimeout || this.requestTimeout, protocols: options.protocols || void (0) }); return transport; }; function clone (obj) { var o = {}; for (var i in obj) { if (obj.hasOwnProperty(i)) { o[i] = obj[i]; } } return o; } /** * Initializes transport to use and starts probe. * * @api private */ Socket.prototype.open = function () { var transport; if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) { transport = 'websocket'; } else if (0 === this.transports.length) { // Emit error on next tick so it can be listened to var self = this; setTimeout(function () { self.emit('error', 'No transports available'); }, 0); return; } else { transport = this.transports[0]; } this.readyState = 'opening'; // Retry with the next transport if the transport is disabled (jsonp: false) try { transport = this.createTransport(transport); } catch (e) { this.transports.shift(); this.open(); return; } transport.open(); this.setTransport(transport); }; /** * Sets the current transport. Disables the existing one (if any). * * @api private */ Socket.prototype.setTransport = function (transport) { var self = this; if (this.transport) { this.transport.removeAllListeners(); } // set up transport this.transport = transport; // set up transport listeners transport .on('drain', function () { self.onDrain(); }) .on('packet', function (packet) { self.onPacket(packet); }) .on('error', function (e) { self.onError(e); }) .on('close', function () { self.onClose('transport close'); }); }; /** * Probes a transport. * * @param {String} transport name * @api private */ Socket.prototype.probe = function (name) { var transport = this.createTransport(name, { probe: 1 }); var failed = false; var self = this; Socket.priorWebsocketSuccess = false; function onTransportOpen () { if (self.onlyBinaryUpgrades) { var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary; failed = failed || upgradeLosesBinary; } if (failed) return; transport.send([{ type: 'ping', data: 'probe' }]); transport.once('packet', function (msg) { if (failed) return; if ('pong' === msg.type && 'probe' === msg.data) { self.upgrading = true; self.emit('upgrading', transport); if (!transport) return; Socket.priorWebsocketSuccess = 'websocket' === transport.name; self.transport.pause(function () { if (failed) return; if ('closed' === self.readyState) return; cleanup(); self.setTransport(transport); transport.send([{ type: 'upgrade' }]); self.emit('upgrade', transport); transport = null; self.upgrading = false; self.flush(); }); } else { var err = new Error('probe error'); err.transport = transport.name; self.emit('upgradeError', err); } }); } function freezeTransport () { if (failed) return; // Any callback called by transport should be ignored since now failed = true; cleanup(); transport.close(); transport = null; } // Handle any error that happens while probing function onerror (err) { var error = new Error('probe error: ' + err); error.transport = transport.name; freezeTransport(); self.emit('upgradeError', error); } function onTransportClose () { onerror('transport closed'); } // When the socket is closed while we're probing function onclose () { onerror('socket closed'); } // When the socket is upgraded while we're probing function onupgrade (to) { if (transport && to.name !== transport.name) { freezeTransport(); } } // Remove all listeners on the transport and on self function cleanup () { transport.removeListener('open', onTransportOpen); transport.removeListener('error', onerror); transport.removeListener('close', onTransportClose); self.removeListener('close', onclose); self.removeListener('upgrading', onupgrade); } transport.once('open', onTransportOpen); transport.once('error', onerror); transport.once('close', onTransportClose); this.once('close', onclose); this.once('upgrading', onupgrade); transport.open(); }; /** * Called when connection is deemed open. * * @api public */ Socket.prototype.onOpen = function () { this.readyState = 'open'; Socket.priorWebsocketSuccess = 'websocket' === this.transport.name; this.emit('open'); this.flush(); // we check for `readyState` in case an `open` // listener already closed the socket if ('open' === this.readyState && this.upgrade && this.transport.pause) { for (var i = 0, l = this.upgrades.length; i < l; i++) { this.probe(this.upgrades[i]); } } }; /** * Handles a packet. * * @api private */ Socket.prototype.onPacket = function (packet) { if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) { this.emit('packet', packet); // Socket is live - any packet counts this.emit('heartbeat'); switch (packet.type) { case 'open': this.onHandshake(JSON.parse(packet.data)); break; case 'pong': this.setPing(); this.emit('pong'); break; case 'error': var err = new Error('server error'); err.code = packet.data; this.onError(err); break; case 'message': this.emit('data', packet.data); this.emit('message', packet.data); break; } } else { } }; /** * Called upon handshake completion. * * @param {Object} handshake obj * @api private */ Socket.prototype.onHandshake = function (data) { this.emit('handshake', data); this.id = data.sid; this.transport.query.sid = data.sid; this.upgrades = this.filterUpgrades(data.upgrades); this.pingInterval = data.pingInterval; this.pingTimeout = data.pingTimeout; this.onOpen(); // In case open handler closes socket if ('closed' === this.readyState) return; this.setPing(); // Prolong liveness of socket on heartbeat this.removeListener('heartbeat', this.onHeartbeat); this.on('heartbeat', this.onHeartbeat); }; /** * Resets ping timeout. * * @api private */ Socket.prototype.onHeartbeat = function (timeout) { clearTimeout(this.pingTimeoutTimer); var self = this; self.pingTimeoutTimer = setTimeout(function () { if ('closed' === self.readyState) return; self.onClose('ping timeout'); }, timeout || (self.pingInterval + self.pingTimeout)); }; /** * Pings server every `this.pingInterval` and expects response * within `this.pingTimeout` or closes connection. * * @api private */ Socket.prototype.setPing = function () { var self = this; clearTimeout(self.pingIntervalTimer); self.pingIntervalTimer = setTimeout(function () { self.ping(); self.onHeartbeat(self.pingTimeout); }, self.pingInterval); }; /** * Sends a ping packet. * * @api private */ Socket.prototype.ping = function () { var self = this; this.sendPacket('ping', function () { self.emit('ping'); }); }; /** * Called on `drain` event * * @api private */ Socket.prototype.onDrain = function () { this.writeBuffer.splice(0, this.prevBufferLen); // setting prevBufferLen = 0 is very important // for example, when upgrading, upgrade packet is sent over, // and a nonzero prevBufferLen could cause problems on `drain` this.prevBufferLen = 0; if (0 === this.writeBuffer.length) { this.emit('drain'); } else { this.flush(); } }; /** * Flush write buffers. * * @api private */ Socket.prototype.flush = function () { if ('closed' !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) { this.transport.send(this.writeBuffer); // keep track of current length of writeBuffer // splice writeBuffer and callbackBuffer on `drain` this.prevBufferLen = this.writeBuffer.length; this.emit('flush'); } }; /** * Sends a message. * * @param {String} message. * @param {Function} callback function. * @param {Object} options. * @return {Socket} for chaining. * @api public */ Socket.prototype.write = Socket.prototype.send = function (msg, options, fn) { this.sendPacket('message', msg, options, fn); return this; }; /** * Sends a packet. * * @param {String} packet type. * @param {String} data. * @param {Object} options. * @param {Function} callback function. * @api private */ Socket.prototype.sendPacket = function (type, data, options, fn) { if ('function' === typeof data) { fn = data; data = undefined; } if ('function' === typeof options) { fn = options; options = null; } if ('closing' === this.readyState || 'closed' === this.readyState) { return; } options = options || {}; options.compress = false !== options.compress; var packet = { type: type, data: data, options: options }; this.emit('packetCreate', packet); this.writeBuffer.push(packet); if (fn) this.once('flush', fn); this.flush(); }; /** * Closes the connection. * * @api private */ Socket.prototype.close = function () { if ('opening' === this.readyState || 'open' === this.readyState) { this.readyState = 'closing'; var self = this; if (this.writeBuffer.length) { this.once('drain', function () { if (this.upgrading) { waitForUpgrade(); } else { close(); } }); } else if (this.upgrading) { waitForUpgrade(); } else { close(); } } function close () { self.onClose('forced close'); self.transport.close(); } function cleanupAndClose () { self.removeListener('upgrade', cleanupAndClose); self.removeListener('upgradeError', cleanupAndClose); close(); } function waitForUpgrade () { // wait for upgrade to finish since we can't send packets while pausing a transport self.once('upgrade', cleanupAndClose); self.once('upgradeError', cleanupAndClose); } return this; }; /** * Called upon transport error * * @api private */ Socket.prototype.onError = function (err) { Socket.priorWebsocketSuccess = false; this.emit('error', err); this.onClose('transport error', err); }; /** * Called upon transport close. * * @api private */ Socket.prototype.onClose = function (reason, desc) { if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) { var self = this; // clear timers clearTimeout(this.pingIntervalTimer); clearTimeout(this.pingTimeoutTimer); // stop event from firing again for transport this.transport.removeAllListeners('close'); // ensure transport won't stay open this.transport.close(); // ignore further transport communication this.transport.removeAllListeners(); // set ready state this.readyState = 'closed'; // clear session id this.id = null; // emit close event this.emit('close', reason, desc); // clean buffers after, so users can still // grab the buffers on `close` event self.writeBuffer = []; self.prevBufferLen = 0; } }; /** * Filters upgrades, returning only those matching client transports. * * @param {Array} server upgrades * @api private * */ Socket.prototype.filterUpgrades = function (upgrades) { var filteredUpgrades = []; for (var i = 0, j = upgrades.length; i < j; i++) { if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]); } return filteredUpgrades; }; ////////////////// // WEBPACK FOOTER // ./~/engine.io-client/lib/socket.js // module id = 11 // module chunks = 0",
"/** * Module dependencies */ var XMLHttpRequest = require('xmlhttprequest-ssl'); var XHR = require('./polling-xhr'); var JSONP = require('./polling-jsonp'); var websocket = require('./websocket'); /** * Export transports. */ exports.polling = polling; exports.websocket = websocket; /** * Polling transport polymorphic constructor. * Decides on xhr vs jsonp based on feature detection. * * @api private */ function polling (opts) { var xhr; var xd = false; var xs = false; var jsonp = false !== opts.jsonp; if (global.location) { var isSSL = 'https:' === location.protocol; var port = location.port; // some user agents have empty `location.port` if (!port) { port = isSSL ? 443 : 80; } xd = opts.hostname !== location.hostname || port !== opts.port; xs = opts.secure !== isSSL; } opts.xdomain = xd; opts.xscheme = xs; xhr = new XMLHttpRequest(opts); if ('open' in xhr && !opts.forceJSONP) { return new XHR(opts); } else { if (!jsonp) throw new Error('JSONP disabled'); return new JSONP(opts); } } ////////////////// // WEBPACK FOOTER // ./~/engine.io-client/lib/transports/index.js // module id = 12 // module chunks = 0",
"// browser shim for xmlhttprequest module var hasCORS = require('has-cors'); module.exports = function (opts) { var xdomain = opts.xdomain; // scheme must be same when usign XDomainRequest // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx var xscheme = opts.xscheme; // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default. // https://github.com/Automattic/engine.io-client/pull/217 var enablesXDR = opts.enablesXDR; // XMLHttpRequest can be disabled on IE try { if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) { return new XMLHttpRequest(); } } catch (e) { } // Use XDomainRequest for IE8 if enablesXDR is true // because loading bar keeps flashing when using jsonp-polling // https://github.com/yujiosaka/socke.io-ie8-loading-example try { if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) { return new XDomainRequest(); } } catch (e) { } if (!xdomain) { try { return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP'); } catch (e) { } } }; ////////////////// // WEBPACK FOOTER // ./~/engine.io-client/lib/xmlhttprequest.js // module id = 13 // module chunks = 0",
" /** * Module exports. * * Logic borrowed from Modernizr: * * - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js */ try { module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest(); } catch (err) { // if XMLHttp support is disabled in IE then it will throw // when trying to create module.exports = false; } ////////////////// // WEBPACK FOOTER // ./~/has-cors/index.js // module id = 14 // module chunks = 0",
"/** * Module requirements. */ var XMLHttpRequest = require('xmlhttprequest-ssl'); var Polling = require('./polling'); var Emitter = require('component-emitter'); var inherit = require('component-inherit'); var debug = require('debug')('engine.io-client:polling-xhr'); /** * Module exports. */ module.exports = XHR; module.exports.Request = Request; /** * Empty function */ function empty () {} /** * XHR Polling constructor. * * @param {Object} opts * @api public */ function XHR (opts) { Polling.call(this, opts); this.requestTimeout = opts.requestTimeout; this.extraHeaders = opts.extraHeaders; if (global.location) { var isSSL = 'https:' === location.protocol; var port = location.port; // some user agents have empty `location.port` if (!port) { port = isSSL ? 443 : 80; } this.xd = opts.hostname !== global.location.hostname || port !== opts.port; this.xs = opts.secure !== isSSL; } } /** * Inherits from Polling. */ inherit(XHR, Polling); /** * XHR supports binary */ XHR.prototype.supportsBinary = true; /** * Creates a request. * * @param {String} method * @api private */ XHR.prototype.request = function (opts) { opts = opts || {}; opts.uri = this.uri(); opts.xd = this.xd; opts.xs = this.xs; opts.agent = this.agent || false; opts.supportsBinary = this.supportsBinary; opts.enablesXDR = this.enablesXDR; // SSL options for Node.js client opts.pfx = this.pfx; opts.key = this.key; opts.passphrase = this.passphrase; opts.cert = this.cert; opts.ca = this.ca; opts.ciphers = this.ciphers; opts.rejectUnauthorized = this.rejectUnauthorized; opts.requestTimeout = this.requestTimeout; // other options for Node.js client opts.extraHeaders = this.extraHeaders; return new Request(opts); }; /** * Sends data. * * @param {String} data to send. * @param {Function} called upon flush. * @api private */ XHR.prototype.doWrite = function (data, fn) { var isBinary = typeof data !== 'string' && data !== undefined; var req = this.request({ method: 'POST', data: data, isBinary: isBinary }); var self = this; req.on('success', fn); req.on('error', function (err) { self.onError('xhr post error', err); }); this.sendXhr = req; }; /** * Starts a poll cycle. * * @api private */ XHR.prototype.doPoll = function () { var req = this.request(); var self = this; req.on('data', function (data) { self.onData(data); }); req.on('error', function (err) { self.onError('xhr poll error', err); }); this.pollXhr = req; }; /** * Request constructor * * @param {Object} options * @api public */ function Request (opts) { this.method = opts.method || 'GET'; this.uri = opts.uri; this.xd = !!opts.xd; this.xs = !!opts.xs; this.async = false !== opts.async; this.data = undefined !== opts.data ? opts.data : null; this.agent = opts.agent; this.isBinary = opts.isBinary; this.supportsBinary = opts.supportsBinary; this.enablesXDR = opts.enablesXDR; this.requestTimeout = opts.requestTimeout; // SSL options for Node.js client this.pfx = opts.pfx; this.key = opts.key; this.passphrase = opts.passphrase; this.cert = opts.cert; this.ca = opts.ca; this.ciphers = opts.ciphers; this.rejectUnauthorized = opts.rejectUnauthorized; // other options for Node.js client this.extraHeaders = opts.extraHeaders; this.create(); } /** * Mix in `Emitter`. */ Emitter(Request.prototype); /** * Creates the XHR object and sends the request. * * @api private */ Request.prototype.create = function () { var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR }; // SSL options for Node.js client opts.pfx = this.pfx; opts.key = this.key; opts.passphrase = this.passphrase; opts.cert = this.cert; opts.ca = this.ca; opts.ciphers = this.ciphers; opts.rejectUnauthorized = this.rejectUnauthorized; var xhr = this.xhr = new XMLHttpRequest(opts); var self = this; try { xhr.open(this.method, this.uri, this.async); try { if (this.extraHeaders) { xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true); for (var i in this.extraHeaders) { if (this.extraHeaders.hasOwnProperty(i)) { xhr.setRequestHeader(i, this.extraHeaders[i]); } } } } catch (e) {} if ('POST' === this.method) { try { if (this.isBinary) { xhr.setRequestHeader('Content-type', 'application/octet-stream'); } else { xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8'); } } catch (e) {} } try { xhr.setRequestHeader('Accept', '*/*'); } catch (e) {} // ie6 check if ('withCredentials' in xhr) { xhr.withCredentials = true; } if (this.requestTimeout) { xhr.timeout = this.requestTimeout; } if (this.hasXDR()) { xhr.onload = function () { self.onLoad(); }; xhr.onerror = function () { self.onError(xhr.responseText); }; } else { xhr.onreadystatechange = function () { if (xhr.readyState === 2) { try { var contentType = xhr.getResponseHeader('Content-Type'); if (self.supportsBinary && contentType === 'application/octet-stream') { xhr.responseType = 'arraybuffer'; } } catch (e) {} } if (4 !== xhr.readyState) return; if (200 === xhr.status || 1223 === xhr.status) { self.onLoad(); } else { // make sure the `error` event handler that's user-set // does not throw in the same tick and gets caught here setTimeout(function () { self.onError(xhr.status); }, 0); } }; } xhr.send(this.data); } catch (e) { // Need to defer since .create() is called directly fhrom the constructor // and thus the 'error' event can only be only bound *after* this exception // occurs. Therefore, also, we cannot throw here at all. setTimeout(function () { self.onError(e); }, 0); return; } if (global.document) { this.index = Request.requestsCount++; Request.requests[this.index] = this; } }; /** * Called upon successful response. * * @api private */ Request.prototype.onSuccess = function () { this.emit('success'); this.cleanup(); }; /** * Called if we have data. * * @api private */ Request.prototype.onData = function (data) { this.emit('data', data); this.onSuccess(); }; /** * Called upon error. * * @api private */ Request.prototype.onError = function (err) { this.emit('error', err); this.cleanup(true); }; /** * Cleans up house. * * @api private */ Request.prototype.cleanup = function (fromError) { if ('undefined' === typeof this.xhr || null === this.xhr) { return; } // xmlhttprequest if (this.hasXDR()) { this.xhr.onload = this.xhr.onerror = empty; } else { this.xhr.onreadystatechange = empty; } if (fromError) { try { this.xhr.abort(); } catch (e) {} } if (global.document) { delete Request.requests[this.index]; } this.xhr = null; }; /** * Called upon load. * * @api private */ Request.prototype.onLoad = function () { var data; try { var contentType; try { contentType = this.xhr.getResponseHeader('Content-Type'); } catch (e) {} if (contentType === 'application/octet-stream') { data = this.xhr.response || this.xhr.responseText; } else { data = this.xhr.responseText; } } catch (e) { this.onError(e); } if (null != data) { this.onData(data); } }; /** * Check if it has XDomainRequest. * * @api private */ Request.prototype.hasXDR = function () { return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR; }; /** * Aborts the request. * * @api public */ Request.prototype.abort = function () { this.cleanup(); }; /** * Aborts pending requests when unloading the window. This is needed to prevent * memory leaks (e.g. when using IE) and to ensure that no spurious error is * emitted. */ Request.requestsCount = 0; Request.requests = {}; if (global.document) { if (global.attachEvent) { global.attachEvent('onunload', unloadHandler); } else if (global.addEventListener) { global.addEventListener('beforeunload', unloadHandler, false); } } function unloadHandler () { for (var i in Request.requests) { if (Request.requests.hasOwnProperty(i)) { Request.requests[i].abort(); } } } ////////////////// // WEBPACK FOOTER // ./~/engine.io-client/lib/transports/polling-xhr.js // module id = 15 // module chunks = 0",
"/** * Module dependencies. */ var Transport = require('../transport'); var parseqs = require('parseqs'); var parser = require('engine.io-parser'); var inherit = require('component-inherit'); var yeast = require('yeast'); var debug = require('debug')('engine.io-client:polling'); /** * Module exports. */ module.exports = Polling; /** * Is XHR2 supported? */ var hasXHR2 = (function () { var XMLHttpRequest = require('xmlhttprequest-ssl'); var xhr = new XMLHttpRequest({ xdomain: false }); return null != xhr.responseType; })(); /** * Polling interface. * * @param {Object} opts * @api private */ function Polling (opts) { var forceBase64 = (opts && opts.forceBase64); if (!hasXHR2 || forceBase64) { this.supportsBinary = false; } Transport.call(this, opts); } /** * Inherits from Transport. */ inherit(Polling, Transport); /** * Transport name. */ Polling.prototype.name = 'polling'; /** * Opens the socket (triggers polling). We write a PING message to determine * when the transport is open. * * @api private */ Polling.prototype.doOpen = function () { this.poll(); }; /** * Pauses polling. * * @param {Function} callback upon buffers are flushed and transport is paused * @api private */ Polling.prototype.pause = function (onPause) { var self = this; this.readyState = 'pausing'; function pause () { self.readyState = 'paused'; onPause(); } if (this.polling || !this.writable) { var total = 0; if (this.polling) { total++; this.once('pollComplete', function () { --total || pause(); }); } if (!this.writable) { total++; this.once('drain', function () { --total || pause(); }); } } else { pause(); } }; /** * Starts polling cycle. * * @api public */ Polling.prototype.poll = function () { this.polling = true; this.doPoll(); this.emit('poll'); }; /** * Overloads onData to detect payloads. * * @api private */ Polling.prototype.onData = function (data) { var self = this; var callback = function (packet, index, total) { // if its the first message we consider the transport open if ('opening' === self.readyState) { self.onOpen(); } // if its a close packet, we close the ongoing requests if ('close' === packet.type) { self.onClose(); return false; } // otherwise bypass onData and handle the message self.onPacket(packet); }; // decode payload parser.decodePayload(data, this.socket.binaryType, callback); // if an event did not trigger closing if ('closed' !== this.readyState) { // if we got data we're not polling this.polling = false; this.emit('pollComplete'); if ('open' === this.readyState) { this.poll(); } else { } } }; /** * For polling, send a close packet. * * @api private */ Polling.prototype.doClose = function () { var self = this; function close () { self.write([{ type: 'close' }]); } if ('open' === this.readyState) { close(); } else { // in case we're trying to close while // handshaking is in progress (GH-164) this.once('open', close); } }; /** * Writes a packets payload. * * @param {Array} data packets * @param {Function} drain callback * @api private */ Polling.prototype.write = function (packets) { var self = this; this.writable = false; var callbackfn = function () { self.writable = true; self.emit('drain'); }; parser.encodePayload(packets, this.supportsBinary, function (data) { self.doWrite(data, callbackfn); }); }; /** * Generates uri for connection. * * @api private */ Polling.prototype.uri = function () { var query = this.query || {}; var schema = this.secure ? 'https' : 'http'; var port = ''; // cache busting is forced if (false !== this.timestampRequests) { query[this.timestampParam] = yeast(); } if (!this.supportsBinary && !query.sid) { query.b64 = 1; } query = parseqs.encode(query); // avoid port if default for schema if (this.port && (('https' === schema && Number(this.port) !== 443) || ('http' === schema && Number(this.port) !== 80))) { port = ':' + this.port; } // prepend ? to query if (query.length) { query = '?' + query; } var ipv6 = this.hostname.indexOf(':') !== -1; return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query; }; ////////////////// // WEBPACK FOOTER // ./~/engine.io-client/lib/transports/polling.js // module id = 16 // module chunks = 0",
"/** * Module dependencies. */ var parser = require('engine.io-parser'); var Emitter = require('component-emitter'); /** * Module exports. */ module.exports = Transport; /** * Transport abstract constructor. * * @param {Object} options. * @api private */ function Transport (opts) { this.path = opts.path; this.hostname = opts.hostname; this.port = opts.port; this.secure = opts.secure; this.query = opts.query; this.timestampParam = opts.timestampParam; this.timestampRequests = opts.timestampRequests; this.readyState = ''; this.agent = opts.agent || false; this.socket = opts.socket; this.enablesXDR = opts.enablesXDR; // SSL options for Node.js client this.pfx = opts.pfx; this.key = opts.key; this.passphrase = opts.passphrase; this.cert = opts.cert; this.ca = opts.ca; this.ciphers = opts.ciphers; this.rejectUnauthorized = opts.rejectUnauthorized; this.forceNode = opts.forceNode; // other options for Node.js client this.extraHeaders = opts.extraHeaders; this.localAddress = opts.localAddress; } /** * Mix in `Emitter`. */ Emitter(Transport.prototype); /** * Emits an error. * * @param {String} str * @return {Transport} for chaining * @api public */ Transport.prototype.onError = function (msg, desc) { var err = new Error(msg); err.type = 'TransportError'; err.description = desc; this.emit('error', err); return this; }; /** * Opens the transport. * * @api public */ Transport.prototype.open = function () { if ('closed' === this.readyState || '' === this.readyState) { this.readyState = 'opening'; this.doOpen(); } return this; }; /** * Closes the transport. * * @api private */ Transport.prototype.close = function () { if ('opening' === this.readyState || 'open' === this.readyState) { this.doClose(); this.onClose(); } return this; }; /** * Sends multiple packets. * * @param {Array} packets * @api private */ Transport.prototype.send = function (packets) { if ('open' === this.readyState) { this.write(packets); } else { throw new Error('Transport not open'); } }; /** * Called upon open * * @api private */ Transport.prototype.onOpen = function () { this.readyState = 'open'; this.writable = true; this.emit('open'); }; /** * Called with data. * * @param {String} data * @api private */ Transport.prototype.onData = function (data) { var packet = parser.decodePacket(data, this.socket.binaryType); this.onPacket(packet); }; /** * Called with a decoded packet. */ Transport.prototype.onPacket = function (packet) { this.emit('packet', packet); }; /** * Called upon close. * * @api private */ Transport.prototype.onClose = function () { this.readyState = 'closed'; this.emit('close'); }; ////////////////// // WEBPACK FOOTER // ./~/engine.io-client/lib/transport.js // module id = 17 // module chunks = 0",
"/** * Module dependencies. */ var keys = require('./keys'); var hasBinary = require('has-binary2'); var sliceBuffer = require('arraybuffer.slice'); var after = require('after'); var utf8 = require('./utf8'); var base64encoder; if (global && global.ArrayBuffer) { base64encoder = require('base64-arraybuffer'); } /** * Check if we are running an android browser. That requires us to use * ArrayBuffer with polling transports... * * http://ghinda.net/jpeg-blob-ajax-android/ */ var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent); /** * Check if we are running in PhantomJS. * Uploading a Blob with PhantomJS does not work correctly, as reported here: * https://github.com/ariya/phantomjs/issues/11395 * @type boolean */ var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent); /** * When true, avoids using Blobs to encode payloads. * @type boolean */ var dontSendBlobs = isAndroid || isPhantomJS; /** * Current protocol version. */ exports.protocol = 3; /** * Packet types. */ var packets = exports.packets = { open: 0 // non-ws , close: 1 // non-ws , ping: 2 , pong: 3 , message: 4 , upgrade: 5 , noop: 6 }; var packetslist = keys(packets); /** * Premade error packet. */ var err = { type: 'error', data: 'parser error' }; /** * Create a blob api even for blob builder when vendor prefixes exist */ var Blob = require('blob'); /** * Encodes a packet. * * <packet type id> [ <data> ] * * Example: * * 5hello world * 3 * 4 * * Binary is encoded in an identical principle * * @api private */ exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) { if (typeof supportsBinary === 'function') { callback = supportsBinary; supportsBinary = false; } if (typeof utf8encode === 'function') { callback = utf8encode; utf8encode = null; } var data = (packet.data === undefined) ? undefined : packet.data.buffer || packet.data; if (global.ArrayBuffer && data instanceof ArrayBuffer) { return encodeArrayBuffer(packet, supportsBinary, callback); } else if (Blob && data instanceof global.Blob) { return encodeBlob(packet, supportsBinary, callback); } // might be an object with { base64: true, data: dataAsBase64String } if (data && data.base64) { return encodeBase64Object(packet, callback); } // Sending data as a utf-8 string var encoded = packets[packet.type]; // data fragment is optional if (undefined !== packet.data) { encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data); } return callback('' + encoded); }; function encodeBase64Object(packet, callback) { // packet data is an object { base64: true, data: dataAsBase64String } var message = 'b' + exports.packets[packet.type] + packet.data.data; return callback(message); } /** * Encode packet helpers for binary types */ function encodeArrayBuffer(packet, supportsBinary, callback) { if (!supportsBinary) { return exports.encodeBase64Packet(packet, callback); } var data = packet.data; var contentArray = new Uint8Array(data); var resultBuffer = new Uint8Array(1 + data.byteLength); resultBuffer[0] = packets[packet.type]; for (var i = 0; i < contentArray.length; i++) { resultBuffer[i+1] = contentArray[i]; } return callback(resultBuffer.buffer); } function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) { if (!supportsBinary) { return exports.encodeBase64Packet(packet, callback); } var fr = new FileReader(); fr.onload = function() { packet.data = fr.result; exports.encodePacket(packet, supportsBinary, true, callback); }; return fr.readAsArrayBuffer(packet.data); } function encodeBlob(packet, supportsBinary, callback) { if (!supportsBinary) { return exports.encodeBase64Packet(packet, callback); } if (dontSendBlobs) { return encodeBlobAsArrayBuffer(packet, supportsBinary, callback); } var length = new Uint8Array(1); length[0] = packets[packet.type]; var blob = new Blob([length.buffer, packet.data]); return callback(blob); } /** * Encodes a packet with binary data in a base64 string * * @param {Object} packet, has `type` and `data` * @return {String} base64 encoded message */ exports.encodeBase64Packet = function(packet, callback) { var message = 'b' + exports.packets[packet.type]; if (Blob && packet.data instanceof global.Blob) { var fr = new FileReader(); fr.onload = function() { var b64 = fr.result.split(',')[1]; callback(message + b64); }; return fr.readAsDataURL(packet.data); } var b64data; try { b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data)); } catch (e) { // iPhone Safari doesn't let you apply with typed arrays var typed = new Uint8Array(packet.data); var basic = new Array(typed.length); for (var i = 0; i < typed.length; i++) { basic[i] = typed[i]; } b64data = String.fromCharCode.apply(null, basic); } message += global.btoa(b64data); return callback(message); }; /** * Decodes a packet. Changes format to Blob if requested. * * @return {Object} with `type` and `data` (if any) * @api private */ exports.decodePacket = function (data, binaryType, utf8decode) { if (data === undefined) { return err; } // String data if (typeof data === 'string') { if (data.charAt(0) === 'b') { return exports.decodeBase64Packet(data.substr(1), binaryType); } if (utf8decode) { data = tryDecode(data); if (data === false) { return err; } } var type = data.charAt(0); if (Number(type) != type || !packetslist[type]) { return err; } if (data.length > 1) { return { type: packetslist[type], data: data.substring(1) }; } else { return { type: packetslist[type] }; } } var asArray = new Uint8Array(data); var type = asArray[0]; var rest = sliceBuffer(data, 1); if (Blob && binaryType === 'blob') { rest = new Blob([rest]); } return { type: packetslist[type], data: rest }; }; function tryDecode(data) { try { data = utf8.decode(data, { strict: false }); } catch (e) { return false; } return data; } /** * Decodes a packet encoded in a base64 string * * @param {String} base64 encoded message * @return {Object} with `type` and `data` (if any) */ exports.decodeBase64Packet = function(msg, binaryType) { var type = packetslist[msg.charAt(0)]; if (!base64encoder) { return { type: type, data: { base64: true, data: msg.substr(1) } }; } var data = base64encoder.decode(msg.substr(1)); if (binaryType === 'blob' && Blob) { data = new Blob([data]); } return { type: type, data: data }; }; /** * Encodes multiple messages (payload). * * <length>:data * * Example: * * 11:hello world2:hi * * If any contents are binary, they will be encoded as base64 strings. Base64 * encoded strings are marked with a b before the length specifier * * @param {Array} packets * @api private */ exports.encodePayload = function (packets, supportsBinary, callback) { if (typeof supportsBinary === 'function') { callback = supportsBinary; supportsBinary = null; } var isBinary = hasBinary(packets); if (supportsBinary && isBinary) { if (Blob && !dontSendBlobs) { return exports.encodePayloadAsBlob(packets, callback); } return exports.encodePayloadAsArrayBuffer(packets, callback); } if (!packets.length) { return callback('0:'); } function setLengthHeader(message) { return message.length + ':' + message; } function encodeOne(packet, doneCallback) { exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) { doneCallback(null, setLengthHeader(message)); }); } map(packets, encodeOne, function(err, results) { return callback(results.join('')); }); }; /** * Async array map using after */ function map(ary, each, done) { var result = new Array(ary.length); var next = after(ary.length, done); var eachWithIndex = function(i, el, cb) { each(el, function(error, msg) { result[i] = msg; cb(error, result); }); }; for (var i = 0; i < ary.length; i++) { eachWithIndex(i, ary[i], next); } } /* * Decodes data when a payload is maybe expected. Possible binary contents are * decoded from their base64 representation * * @param {String} data, callback method * @api public */ exports.decodePayload = function (data, binaryType, callback) { if (typeof data !== 'string') { return exports.decodePayloadAsBinary(data, binaryType, callback); } if (typeof binaryType === 'function') { callback = binaryType; binaryType = null; } var packet; if (data === '') { // parser error - ignoring payload return callback(err, 0, 1); } var length = '', n, msg; for (var i = 0, l = data.length; i < l; i++) { var chr = data.charAt(i); if (chr !== ':') { length += chr; continue; } if (length === '' || (length != (n = Number(length)))) { // parser error - ignoring payload return callback(err, 0, 1); } msg = data.substr(i + 1, n); if (length != msg.length) { // parser error - ignoring payload return callback(err, 0, 1); } if (msg.length) { packet = exports.decodePacket(msg, binaryType, false); if (err.type === packet.type && err.data === packet.data) { // parser error in individual packet - ignoring payload return callback(err, 0, 1); } var ret = callback(packet, i + n, l); if (false === ret) return; } // advance cursor i += n; length = ''; } if (length !== '') { // parser error - ignoring payload return callback(err, 0, 1); } }; /** * Encodes multiple messages (payload) as binary. * * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number * 255><data> * * Example: * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers * * @param {Array} packets * @return {ArrayBuffer} encoded payload * @api private */ exports.encodePayloadAsArrayBuffer = function(packets, callback) { if (!packets.length) { return callback(new ArrayBuffer(0)); } function encodeOne(packet, doneCallback) { exports.encodePacket(packet, true, true, function(data) { return doneCallback(null, data); }); } map(packets, encodeOne, function(err, encodedPackets) { var totalLength = encodedPackets.reduce(function(acc, p) { var len; if (typeof p === 'string'){ len = p.length; } else { len = p.byteLength; } return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2 }, 0); var resultArray = new Uint8Array(totalLength); var bufferIndex = 0; encodedPackets.forEach(function(p) { var isString = typeof p === 'string'; var ab = p; if (isString) { var view = new Uint8Array(p.length); for (var i = 0; i < p.length; i++) { view[i] = p.charCodeAt(i); } ab = view.buffer; } if (isString) { // not true binary resultArray[bufferIndex++] = 0; } else { // true binary resultArray[bufferIndex++] = 1; } var lenStr = ab.byteLength.toString(); for (var i = 0; i < lenStr.length; i++) { resultArray[bufferIndex++] = parseInt(lenStr[i]); } resultArray[bufferIndex++] = 255; var view = new Uint8Array(ab); for (var i = 0; i < view.length; i++) { resultArray[bufferIndex++] = view[i]; } }); return callback(resultArray.buffer); }); }; /** * Encode as Blob */ exports.encodePayloadAsBlob = function(packets, callback) { function encodeOne(packet, doneCallback) { exports.encodePacket(packet, true, true, function(encoded) { var binaryIdentifier = new Uint8Array(1); binaryIdentifier[0] = 1; if (typeof encoded === 'string') { var view = new Uint8Array(encoded.length); for (var i = 0; i < encoded.length; i++) { view[i] = encoded.charCodeAt(i); } encoded = view.buffer; binaryIdentifier[0] = 0; } var len = (encoded instanceof ArrayBuffer) ? encoded.byteLength : encoded.size; var lenStr = len.toString(); var lengthAry = new Uint8Array(lenStr.length + 1); for (var i = 0; i < lenStr.length; i++) { lengthAry[i] = parseInt(lenStr[i]); } lengthAry[lenStr.length] = 255; if (Blob) { var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]); doneCallback(null, blob); } }); } map(packets, encodeOne, function(err, results) { return callback(new Blob(results)); }); }; /* * Decodes data when a payload is maybe expected. Strings are decoded by * interpreting each byte as a key code for entries marked to start with 0. See * description of encodePayloadAsBinary * * @param {ArrayBuffer} data, callback method * @api public */ exports.decodePayloadAsBinary = function (data, binaryType, callback) { if (typeof binaryType === 'function') { callback = binaryType; binaryType = null; } var bufferTail = data; var buffers = []; while (bufferTail.byteLength > 0) { var tailArray = new Uint8Array(bufferTail); var isString = tailArray[0] === 0; var msgLength = ''; for (var i = 1; ; i++) { if (tailArray[i] === 255) break; // 310 = char length of Number.MAX_VALUE if (msgLength.length > 310) { return callback(err, 0, 1); } msgLength += tailArray[i]; } bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length); msgLength = parseInt(msgLength); var msg = sliceBuffer(bufferTail, 0, msgLength); if (isString) { try { msg = String.fromCharCode.apply(null, new Uint8Array(msg)); } catch (e) { // iPhone Safari doesn't let you apply to typed arrays var typed = new Uint8Array(msg); msg = ''; for (var i = 0; i < typed.length; i++) { msg += String.fromCharCode(typed[i]); } } } buffers.push(msg); bufferTail = sliceBuffer(bufferTail, msgLength); } var total = buffers.length; buffers.forEach(function(buffer, i) { callback(exports.decodePacket(buffer, binaryType, true), i, total); }); }; ////////////////// // WEBPACK FOOTER // ./~/engine.io-parser/lib/browser.js // module id = 18 // module chunks = 0",
" /** * Gets the keys for an object. * * @return {Array} keys * @api private */ module.exports = Object.keys || function keys (obj){ var arr = []; var has = Object.prototype.hasOwnProperty; for (var i in obj) { if (has.call(obj, i)) { arr.push(i); } } return arr; }; ////////////////// // WEBPACK FOOTER // ./~/engine.io-parser/lib/keys.js // module id = 19 // module chunks = 0",
"/* global Blob File */ /* * Module requirements. */ var isArray = require('isarray'); var toString = Object.prototype.toString; var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]'; var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]'; /** * Module exports. */ module.exports = hasBinary; /** * Checks for binary data. * * Supports Buffer, ArrayBuffer, Blob and File. * * @param {Object} anything * @api public */ function hasBinary (obj) { if (!obj || typeof obj !== 'object') { return false; } if (isArray(obj)) { for (var i = 0, l = obj.length; i < l; i++) { if (hasBinary(obj[i])) { return true; } } return false; } if ((typeof global.Buffer === 'function' && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) || (typeof global.ArrayBuffer === 'function' && obj instanceof ArrayBuffer) || (withNativeBlob && obj instanceof Blob) || (withNativeFile && obj instanceof File) ) { return true; } // see: https://github.com/Automattic/has-binary/pull/4 if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) { return hasBinary(obj.toJSON(), true); } for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) { return true; } } return false; } ////////////////// // WEBPACK FOOTER // ./~/has-binary2/index.js // module id = 20 // module chunks = 0",
"/** * An abstraction for slicing an arraybuffer even when * ArrayBuffer.prototype.slice is not supported * * @api public */ module.exports = function(arraybuffer, start, end) { var bytes = arraybuffer.byteLength; start = start || 0; end = end || bytes; if (arraybuffer.slice) { return arraybuffer.slice(start, end); } if (start < 0) { start += bytes; } if (end < 0) { end += bytes; } if (end > bytes) { end = bytes; } if (start >= bytes || start >= end || bytes === 0) { return new ArrayBuffer(0); } var abv = new Uint8Array(arraybuffer); var result = new Uint8Array(end - start); for (var i = start, ii = 0; i < end; i++, ii++) { result[ii] = abv[i]; } return result.buffer; }; ////////////////// // WEBPACK FOOTER // ./~/arraybuffer.slice/index.js // module id = 21 // module chunks = 0",
"module.exports = after function after(count, callback, err_cb) { var bail = false err_cb = err_cb || noop proxy.count = count return (count === 0) ? callback() : proxy function proxy(err, result) { if (proxy.count <= 0) { throw new Error('after called too many times') } --proxy.count // after first error, rest are passed to err_cb if (err) { bail = true callback(err) // future error callbacks will go to error handler callback = err_cb } else if (proxy.count === 0 && !bail) { callback(null, result) } } } function noop() {} ////////////////// // WEBPACK FOOTER // ./~/after/index.js // module id = 22 // module chunks = 0",
"/*! https://mths.be/utf8js v2.1.2 by @mathias */ ;(function(root) { // Detect free variables `exports` var freeExports = typeof exports == 'object' && exports; // Detect free variable `module` var freeModule = typeof module == 'object' && module && module.exports == freeExports && module; // Detect free variable `global`, from Node.js or Browserified code, // and use it as `root` var freeGlobal = typeof global == 'object' && global; if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) { root = freeGlobal; } /*--------------------------------------------------------------------------*/ var stringFromCharCode = String.fromCharCode; // Taken from https://mths.be/punycode function ucs2decode(string) { var output = []; var counter = 0; var length = string.length; var value; var extra; while (counter < length) { value = string.charCodeAt(counter++); if (value >= 0xD800 && value <= 0xDBFF && counter < length) { // high surrogate, and there is a next character extra = string.charCodeAt(counter++); if ((extra & 0xFC00) == 0xDC00) { // low surrogate output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000); } else { // unmatched surrogate; only append this code unit, in case the next // code unit is the high surrogate of a surrogate pair output.push(value); counter--; } } else { output.push(value); } } return output; } // Taken from https://mths.be/punycode function ucs2encode(array) { var length = array.length; var index = -1; var value; var output = ''; while (++index < length) { value = array[index]; if (value > 0xFFFF) { value -= 0x10000; output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800); value = 0xDC00 | value & 0x3FF; } output += stringFromCharCode(value); } return output; } function checkScalarValue(codePoint, strict) { if (codePoint >= 0xD800 && codePoint <= 0xDFFF) { if (strict) { throw Error( 'Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value' ); } return false; } return true; } /*--------------------------------------------------------------------------*/ function createByte(codePoint, shift) { return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80); } function encodeCodePoint(codePoint, strict) { if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence return stringFromCharCode(codePoint); } var symbol = ''; if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0); } else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence if (!checkScalarValue(codePoint, strict)) { codePoint = 0xFFFD; } symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0); symbol += createByte(codePoint, 6); } else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0); symbol += createByte(codePoint, 12); symbol += createByte(codePoint, 6); } symbol += stringFromCharCode((codePoint & 0x3F) | 0x80); return symbol; } function utf8encode(string, opts) { opts = opts || {}; var strict = false !== opts.strict; var codePoints = ucs2decode(string); var length = codePoints.length; var index = -1; var codePoint; var byteString = ''; while (++index < length) { codePoint = codePoints[index]; byteString += encodeCodePoint(codePoint, strict); } return byteString; } /*--------------------------------------------------------------------------*/ function readContinuationByte() { if (byteIndex >= byteCount) { throw Error('Invalid byte index'); } var continuationByte = byteArray[byteIndex] & 0xFF; byteIndex++; if ((continuationByte & 0xC0) == 0x80) { return continuationByte & 0x3F; } // If we end up here, its not a continuation byte throw Error('Invalid continuation byte'); } function decodeSymbol(strict) { var byte1; var byte2; var byte3; var byte4; var codePoint; if (byteIndex > byteCount) { throw Error('Invalid byte index'); } if (byteIndex == byteCount) { return false; } // Read first byte byte1 = byteArray[byteIndex] & 0xFF; byteIndex++; // 1-byte sequence (no continuation bytes) if ((byte1 & 0x80) == 0) { return byte1; } // 2-byte sequence if ((byte1 & 0xE0) == 0xC0) { byte2 = readContinuationByte(); codePoint = ((byte1 & 0x1F) << 6) | byte2; if (codePoint >= 0x80) { return codePoint; } else { throw Error('Invalid continuation byte'); } } // 3-byte sequence (may include unpaired surrogates) if ((byte1 & 0xF0) == 0xE0) { byte2 = readContinuationByte(); byte3 = readContinuationByte(); codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3; if (codePoint >= 0x0800) { return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD; } else { throw Error('Invalid continuation byte'); } } // 4-byte sequence if ((byte1 & 0xF8) == 0xF0) { byte2 = readContinuationByte(); byte3 = readContinuationByte(); byte4 = readContinuationByte(); codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) | (byte3 << 0x06) | byte4; if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) { return codePoint; } } throw Error('Invalid UTF-8 detected'); } var byteArray; var byteCount; var byteIndex; function utf8decode(byteString, opts) { opts = opts || {}; var strict = false !== opts.strict; byteArray = ucs2decode(byteString); byteCount = byteArray.length; byteIndex = 0; var codePoints = []; var tmp; while ((tmp = decodeSymbol(strict)) !== false) { codePoints.push(tmp); } return ucs2encode(codePoints); } /*--------------------------------------------------------------------------*/ var utf8 = { 'version': '2.1.2', 'encode': utf8encode, 'decode': utf8decode }; // Some AMD build optimizers, like r.js, check for specific condition patterns // like the following: if ( typeof define == 'function' && typeof define.amd == 'object' && define.amd ) { define(function() { return utf8; }); }	else if (freeExports && !freeExports.nodeType) { if (freeModule) { // in Node.js or RingoJS v0.8.0+ freeModule.exports = utf8; } else { // in Narwhal or RingoJS v0.7.0- var object = {}; var hasOwnProperty = object.hasOwnProperty; for (var key in utf8) { hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]); } } } else { // in Rhino or a web browser root.utf8 = utf8; } }(this)); ////////////////// // WEBPACK FOOTER // ./~/engine.io-parser/lib/utf8.js // module id = 23 // module chunks = 0",
"module.exports = function(module) { if(!module.webpackPolyfill) { module.deprecate = function() {}; module.paths = []; // module.parent = undefined by default module.children = []; module.webpackPolyfill = 1; } return module; } ////////////////// // WEBPACK FOOTER // (webpack)/buildin/module.js // module id = 24 // module chunks = 0",
"/* * base64-arraybuffer * https://github.com/niklasvh/base64-arraybuffer * * Copyright (c) 2012 Niklas von Hertzen * Licensed under the MIT license. */ (function(){ "use strict"; var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // Use a lookup table to find the index. var lookup = new Uint8Array(256); for (var i = 0; i < chars.length; i++) { lookup[chars.charCodeAt(i)] = i; } exports.encode = function(arraybuffer) { var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = ""; for (i = 0; i < len; i+=3) { base64 += chars[bytes[i] >> 2]; base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)]; base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)]; base64 += chars[bytes[i + 2] & 63]; } if ((len % 3) === 2) { base64 = base64.substring(0, base64.length - 1) + "="; } else if (len % 3 === 1) { base64 = base64.substring(0, base64.length - 2) + "=="; } return base64; }; exports.decode = function(base64) { var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4; if (base64[base64.length - 1] === "=") { bufferLength--; if (base64[base64.length - 2] === "=") { bufferLength--; } } var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer); for (i = 0; i < len; i+=4) { encoded1 = lookup[base64.charCodeAt(i)]; encoded2 = lookup[base64.charCodeAt(i+1)]; encoded3 = lookup[base64.charCodeAt(i+2)]; encoded4 = lookup[base64.charCodeAt(i+3)]; bytes[p++] = (encoded1 << 2) | (encoded2 >> 4); bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2); bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63); } return arraybuffer; }; })(); ////////////////// // WEBPACK FOOTER // ./~/base64-arraybuffer/lib/base64-arraybuffer.js // module id = 25 // module chunks = 0",
"/** * Create a blob builder even when vendor prefixes exist */ var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder; /** * Check if Blob constructor is supported */ var blobSupported = (function() { try { var a = new Blob(['hi']); return a.size === 2; } catch(e) { return false; } })(); /** * Check if Blob constructor supports ArrayBufferViews * Fails in Safari 6, so we need to map to ArrayBuffers there. */ var blobSupportsArrayBufferView = blobSupported && (function() { try { var b = new Blob([new Uint8Array([1,2])]); return b.size === 2; } catch(e) { return false; } })(); /** * Check if BlobBuilder is supported */ var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob; /** * Helper function that maps ArrayBufferViews to ArrayBuffers * Used by BlobBuilder constructor and old browsers that didn't * support it in the Blob constructor. */ function mapArrayBufferViews(ary) { for (var i = 0; i < ary.length; i++) { var chunk = ary[i]; if (chunk.buffer instanceof ArrayBuffer) { var buf = chunk.buffer; // if this is a subarray, make a copy so we only // include the subarray region from the underlying buffer if (chunk.byteLength !== buf.byteLength) { var copy = new Uint8Array(chunk.byteLength); copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength)); buf = copy.buffer; } ary[i] = buf; } } } function BlobBuilderConstructor(ary, options) { options = options || {}; var bb = new BlobBuilder(); mapArrayBufferViews(ary); for (var i = 0; i < ary.length; i++) { bb.append(ary[i]); } return (options.type) ? bb.getBlob(options.type) : bb.getBlob(); }; function BlobConstructor(ary, options) { mapArrayBufferViews(ary); return new Blob(ary, options || {}); }; module.exports = (function() { if (blobSupported) { return blobSupportsArrayBufferView ? global.Blob : BlobConstructor; } else if (blobBuilderSupported) { return BlobBuilderConstructor; } else { return undefined; } })(); ////////////////// // WEBPACK FOOTER // ./~/blob/index.js // module id = 26 // module chunks = 0",
"/** * Compiles a querystring * Returns string representation of the object * * @param {Object} * @api private */ exports.encode = function (obj) { var str = ''; for (var i in obj) { if (obj.hasOwnProperty(i)) { if (str.length) str += '&'; str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]); } } return str; }; /** * Parses a simple querystring into an object * * @param {String} qs * @api private */ exports.decode = function(qs){ var qry = {}; var pairs = qs.split('&'); for (var i = 0, l = pairs.length; i < l; i++) { var pair = pairs[i].split('='); qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]); } return qry; }; ////////////////// // WEBPACK FOOTER // ./~/parseqs/index.js // module id = 27 // module chunks = 0",
" module.exports = function(a, b){ var fn = function(){}; fn.prototype = b.prototype; a.prototype = new fn; a.prototype.constructor = a; }; ////////////////// // WEBPACK FOOTER // ./~/component-inherit/index.js // module id = 28 // module chunks = 0",
"'use strict'; var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('') , length = 64 , map = {} , seed = 0 , i = 0 , prev; /** * Return a string representing the specified number. * * @param {Number} num The number to convert. * @returns {String} The string representation of the number. * @api public */ function encode(num) { var encoded = ''; do { encoded = alphabet[num % length] + encoded; num = Math.floor(num / length); } while (num > 0); return encoded; } /** * Return the integer value specified by the given string. * * @param {String} str The string to convert. * @returns {Number} The integer value represented by the string. * @api public */ function decode(str) { var decoded = 0; for (i = 0; i < str.length; i++) { decoded = decoded * length + map[str.charAt(i)]; } return decoded; } /** * Yeast: A tiny growing id generator. * * @returns {String} A unique id. * @api public */ function yeast() { var now = encode(+new Date()); if (now !== prev) return seed = 0, prev = now; return now +'.'+ encode(seed++); } // // Map each character to its index. // for (; i < length; i++) map[alphabet[i]] = i; // // Expose the `yeast`, `encode` and `decode` functions. // yeast.encode = encode; yeast.decode = decode; module.exports = yeast; ////////////////// // WEBPACK FOOTER // ./~/yeast/index.js // module id = 29 // module chunks = 0",
" /** * Module requirements. */ var Polling = require('./polling'); var inherit = require('component-inherit'); /** * Module exports. */ module.exports = JSONPPolling; /** * Cached regular expressions. */ var rNewline = /\n/g; var rEscapedNewline = /\\n/g; /** * Global JSONP callbacks. */ var callbacks; /** * Noop. */ function empty () { } /** * JSONP Polling constructor. * * @param {Object} opts. * @api public */ function JSONPPolling (opts) { Polling.call(this, opts); this.query = this.query || {}; // define global callbacks array if not present // we do this here (lazily) to avoid unneeded global pollution if (!callbacks) { // we need to consider multiple engines in the same page if (!global.___eio) global.___eio = []; callbacks = global.___eio; } // callback identifier this.index = callbacks.length; // add callback to jsonp global var self = this; callbacks.push(function (msg) { self.onData(msg); }); // append to query string this.query.j = this.index; // prevent spurious errors from being emitted when the window is unloaded if (global.document && global.addEventListener) { global.addEventListener('beforeunload', function () { if (self.script) self.script.onerror = empty; }, false); } } /** * Inherits from Polling. */ inherit(JSONPPolling, Polling); /* * JSONP only supports binary as base64 encoded strings */ JSONPPolling.prototype.supportsBinary = false; /** * Closes the socket. * * @api private */ JSONPPolling.prototype.doClose = function () { if (this.script) { this.script.parentNode.removeChild(this.script); this.script = null; } if (this.form) { this.form.parentNode.removeChild(this.form); this.form = null; this.iframe = null; } Polling.prototype.doClose.call(this); }; /** * Starts a poll cycle. * * @api private */ JSONPPolling.prototype.doPoll = function () { var self = this; var script = document.createElement('script'); if (this.script) { this.script.parentNode.removeChild(this.script); this.script = null; } script.async = true; script.src = this.uri(); script.onerror = function (e) { self.onError('jsonp poll error', e); }; var insertAt = document.getElementsByTagName('script')[0]; if (insertAt) { insertAt.parentNode.insertBefore(script, insertAt); } else { (document.head || document.body).appendChild(script); } this.script = script; var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent); if (isUAgecko) { setTimeout(function () { var iframe = document.createElement('iframe'); document.body.appendChild(iframe); document.body.removeChild(iframe); }, 100); } }; /** * Writes with a hidden iframe. * * @param {String} data to send * @param {Function} called upon flush. * @api private */ JSONPPolling.prototype.doWrite = function (data, fn) { var self = this; if (!this.form) { var form = document.createElement('form'); var area = document.createElement('textarea'); var id = this.iframeId = 'eio_iframe_' + this.index; var iframe; form.className = 'socketio'; form.style.position = 'absolute'; form.style.top = '-1000px'; form.style.left = '-1000px'; form.target = id; form.method = 'POST'; form.setAttribute('accept-charset', 'utf-8'); area.name = 'd'; form.appendChild(area); document.body.appendChild(form); this.form = form; this.area = area; } this.form.action = this.uri(); function complete () { initIframe(); fn(); } function initIframe () { if (self.iframe) { try { self.form.removeChild(self.iframe); } catch (e) { self.onError('jsonp polling iframe removal error', e); } } try { // ie6 dynamic iframes with target="" support (thanks Chris Lambacher) var html = '<iframe src="javascript:0" name="' + self.iframeId + '">'; iframe = document.createElement(html); } catch (e) { iframe = document.createElement('iframe'); iframe.name = self.iframeId; iframe.src = 'javascript:0'; } iframe.id = self.iframeId; self.form.appendChild(iframe); self.iframe = iframe; } initIframe(); // escape \n to prevent it from being converted into \r\n by some UAs // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side data = data.replace(rEscapedNewline, '\\\n'); this.area.value = data.replace(rNewline, '\\n'); try { this.form.submit(); } catch (e) {} if (this.iframe.attachEvent) { this.iframe.onreadystatechange = function () { if (self.iframe.readyState === 'complete') { complete(); } }; } else { this.iframe.onload = complete; } }; ////////////////// // WEBPACK FOOTER // ./~/engine.io-client/lib/transports/polling-jsonp.js // module id = 30 // module chunks = 0",
"/** * Module dependencies. */ var Transport = require('../transport'); var parser = require('engine.io-parser'); var parseqs = require('parseqs'); var inherit = require('component-inherit'); var yeast = require('yeast'); var debug = require('debug')('engine.io-client:websocket'); var BrowserWebSocket = global.WebSocket || global.MozWebSocket; var NodeWebSocket; if (typeof window === 'undefined') { try { NodeWebSocket = require('ws'); } catch (e) { } } /** * Get either the `WebSocket` or `MozWebSocket` globals * in the browser or try to resolve WebSocket-compatible * interface exposed by `ws` for Node-like environment. */ var WebSocket = BrowserWebSocket; if (!WebSocket && typeof window === 'undefined') { WebSocket = NodeWebSocket; } /** * Module exports. */ module.exports = WS; /** * WebSocket transport constructor. * * @api {Object} connection options * @api public */ function WS (opts) { var forceBase64 = (opts && opts.forceBase64); if (forceBase64) { this.supportsBinary = false; } this.perMessageDeflate = opts.perMessageDeflate; this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode; this.protocols = opts.protocols; if (!this.usingBrowserWebSocket) { WebSocket = NodeWebSocket; } Transport.call(this, opts); } /** * Inherits from Transport. */ inherit(WS, Transport); /** * Transport name. * * @api public */ WS.prototype.name = 'websocket'; /* * WebSockets support binary */ WS.prototype.supportsBinary = true; /** * Opens socket. * * @api private */ WS.prototype.doOpen = function () { if (!this.check()) { // let probe timeout return; } var uri = this.uri(); var protocols = this.protocols; var opts = { agent: this.agent, perMessageDeflate: this.perMessageDeflate }; // SSL options for Node.js client opts.pfx = this.pfx; opts.key = this.key; opts.passphrase = this.passphrase; opts.cert = this.cert; opts.ca = this.ca; opts.ciphers = this.ciphers; opts.rejectUnauthorized = this.rejectUnauthorized; if (this.extraHeaders) { opts.headers = this.extraHeaders; } if (this.localAddress) { opts.localAddress = this.localAddress; } try { this.ws = this.usingBrowserWebSocket ? (protocols ? new WebSocket(uri, protocols) : new WebSocket(uri)) : new WebSocket(uri, protocols, opts); } catch (err) { return this.emit('error', err); } if (this.ws.binaryType === undefined) { this.supportsBinary = false; } if (this.ws.supports && this.ws.supports.binary) { this.supportsBinary = true; this.ws.binaryType = 'nodebuffer'; } else { this.ws.binaryType = 'arraybuffer'; } this.addEventListeners(); }; /** * Adds event listeners to the socket * * @api private */ WS.prototype.addEventListeners = function () { var self = this; this.ws.onopen = function () { self.onOpen(); }; this.ws.onclose = function () { self.onClose(); }; this.ws.onmessage = function (ev) { self.onData(ev.data); }; this.ws.onerror = function (e) { self.onError('websocket error', e); }; }; /** * Writes data to socket. * * @param {Array} array of packets. * @api private */ WS.prototype.write = function (packets) { var self = this; this.writable = false; // encodePacket efficient as it uses WS framing // no need for encodePayload var total = packets.length; for (var i = 0, l = total; i < l; i++) { (function (packet) { parser.encodePacket(packet, self.supportsBinary, function (data) { if (!self.usingBrowserWebSocket) { // always create a new object (GH-437) var opts = {}; if (packet.options) { opts.compress = packet.options.compress; } if (self.perMessageDeflate) { var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length; if (len < self.perMessageDeflate.threshold) { opts.compress = false; } } } // Sometimes the websocket has already been closed but the browser didn't // have a chance of informing us about it yet, in that case send will // throw an error try { if (self.usingBrowserWebSocket) { // TypeError is thrown when passing the second argument on Safari self.ws.send(data); } else { self.ws.send(data, opts); } } catch (e) { } --total || done(); }); })(packets[i]); } function done () { self.emit('flush'); // fake drain // defer to next tick to allow Socket to clear writeBuffer setTimeout(function () { self.writable = true; self.emit('drain'); }, 0); } }; /** * Called upon close * * @api private */ WS.prototype.onClose = function () { Transport.prototype.onClose.call(this); }; /** * Closes socket. * * @api private */ WS.prototype.doClose = function () { if (typeof this.ws !== 'undefined') { this.ws.close(); } }; /** * Generates uri for connection. * * @api private */ WS.prototype.uri = function () { var query = this.query || {}; var schema = this.secure ? 'wss' : 'ws'; var port = ''; // avoid port if default for schema if (this.port && (('wss' === schema && Number(this.port) !== 443) || ('ws' === schema && Number(this.port) !== 80))) { port = ':' + this.port; } // append timestamp to URI if (this.timestampRequests) { query[this.timestampParam] = yeast(); } // communicate binary support capabilities if (!this.supportsBinary) { query.b64 = 1; } query = parseqs.encode(query); // prepend ? to query if (query.length) { query = '?' + query; } var ipv6 = this.hostname.indexOf(':') !== -1; return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query; }; /** * Feature detection for WebSocket. * * @return {Boolean} whether this transport is available. * @api public */ WS.prototype.check = function () { return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name); }; ////////////////// // WEBPACK FOOTER // ./~/engine.io-client/lib/transports/websocket.js // module id = 31 // module chunks = 0",
" var indexOf = [].indexOf; module.exports = function(arr, obj){ if (indexOf) return arr.indexOf(obj); for (var i = 0; i < arr.length; ++i) { if (arr[i] === obj) return i; } return -1; }; ////////////////// // WEBPACK FOOTER // ./~/indexof/index.js // module id = 33 // module chunks = 0",
" /** * Module dependencies. */ var parser = require('socket.io-parser'); var Emitter = require('component-emitter'); var toArray = require('to-array'); var on = require('./on'); var bind = require('component-bind'); var debug = require('debug')('socket.io-client:socket'); var parseqs = require('parseqs'); var hasBin = require('has-binary2'); /** * Module exports. */ module.exports = exports = Socket; /** * Internal events (blacklisted). * These events can't be emitted by the user. * * @api private */ var events = { connect: 1, connect_error: 1, connect_timeout: 1, connecting: 1, disconnect: 1, error: 1, reconnect: 1, reconnect_attempt: 1, reconnect_failed: 1, reconnect_error: 1, reconnecting: 1, ping: 1, pong: 1 }; /** * Shortcut to `Emitter#emit`. */ var emit = Emitter.prototype.emit; /** * `Socket` constructor. * * @api public */ function Socket (io, nsp, opts) { this.io = io; this.nsp = nsp; this.json = this; // compat this.ids = 0; this.acks = {}; this.receiveBuffer = []; this.sendBuffer = []; this.connected = false; this.disconnected = true; this.flags = {}; if (opts && opts.query) { this.query = opts.query; } if (this.io.autoConnect) this.open(); } /** * Mix in `Emitter`. */ Emitter(Socket.prototype); /** * Subscribe to open, close and packet events * * @api private */ Socket.prototype.subEvents = function () { if (this.subs) return; var io = this.io; this.subs = [ on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose')) ]; }; /** * "Opens" the socket. * * @api public */ Socket.prototype.open = Socket.prototype.connect = function () { if (this.connected) return this; this.subEvents(); this.io.open(); // ensure open if ('open' === this.io.readyState) this.onopen(); this.emit('connecting'); return this; }; /** * Sends a `message` event. * * @return {Socket} self * @api public */ Socket.prototype.send = function () { var args = toArray(arguments); args.unshift('message'); this.emit.apply(this, args); return this; }; /** * Override `emit`. * If the event is in `events`, it's emitted normally. * * @param {String} event name * @return {Socket} self * @api public */ Socket.prototype.emit = function (ev) { if (events.hasOwnProperty(ev)) { emit.apply(this, arguments); return this; } var args = toArray(arguments); var packet = { type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT, data: args }; packet.options = {}; packet.options.compress = !this.flags || false !== this.flags.compress; // event ack callback if ('function' === typeof args[args.length - 1]) { this.acks[this.ids] = args.pop(); packet.id = this.ids++; } if (this.connected) { this.packet(packet); } else { this.sendBuffer.push(packet); } this.flags = {}; return this; }; /** * Sends a packet. * * @param {Object} packet * @api private */ Socket.prototype.packet = function (packet) { packet.nsp = this.nsp; this.io.packet(packet); }; /** * Called upon engine `open`. * * @api private */ Socket.prototype.onopen = function () { // write connect packet if necessary if ('/' !== this.nsp) { if (this.query) { var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query; this.packet({type: parser.CONNECT, query: query}); } else { this.packet({type: parser.CONNECT}); } } }; /** * Called upon engine `close`. * * @param {String} reason * @api private */ Socket.prototype.onclose = function (reason) { this.connected = false; this.disconnected = true; delete this.id; this.emit('disconnect', reason); }; /** * Called with socket packet. * * @param {Object} packet * @api private */ Socket.prototype.onpacket = function (packet) { var sameNamespace = packet.nsp === this.nsp; var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/'; if (!sameNamespace && !rootNamespaceError) return; switch (packet.type) { case parser.CONNECT: this.onconnect(); break; case parser.EVENT: this.onevent(packet); break; case parser.BINARY_EVENT: this.onevent(packet); break; case parser.ACK: this.onack(packet); break; case parser.BINARY_ACK: this.onack(packet); break; case parser.DISCONNECT: this.ondisconnect(); break; case parser.ERROR: this.emit('error', packet.data); break; } }; /** * Called upon a server event. * * @param {Object} packet * @api private */ Socket.prototype.onevent = function (packet) { var args = packet.data || []; if (null != packet.id) { args.push(this.ack(packet.id)); } if (this.connected) { emit.apply(this, args); } else { this.receiveBuffer.push(args); } }; /** * Produces an ack callback to emit with an event. * * @api private */ Socket.prototype.ack = function (id) { var self = this; var sent = false; return function () { // prevent double callbacks if (sent) return; sent = true; var args = toArray(arguments); self.packet({ type: hasBin(args) ? parser.BINARY_ACK : parser.ACK, id: id, data: args }); }; }; /** * Called upon a server acknowlegement. * * @param {Object} packet * @api private */ Socket.prototype.onack = function (packet) { var ack = this.acks[packet.id]; if ('function' === typeof ack) { ack.apply(this, packet.data); delete this.acks[packet.id]; } else { } }; /** * Called upon server connect. * * @api private */ Socket.prototype.onconnect = function () { this.connected = true; this.disconnected = false; this.emit('connect'); this.emitBuffered(); }; /** * Emit buffered events (received and emitted). * * @api private */ Socket.prototype.emitBuffered = function () { var i; for (i = 0; i < this.receiveBuffer.length; i++) { emit.apply(this, this.receiveBuffer[i]); } this.receiveBuffer = []; for (i = 0; i < this.sendBuffer.length; i++) { this.packet(this.sendBuffer[i]); } this.sendBuffer = []; }; /** * Called upon server disconnect. * * @api private */ Socket.prototype.ondisconnect = function () { this.destroy(); this.onclose('io server disconnect'); }; /** * Called upon forced client/server side disconnections, * this method ensures the manager stops tracking us and * that reconnections don't get triggered for this. * * @api private. */ Socket.prototype.destroy = function () { if (this.subs) { // clean subscriptions to avoid reconnections for (var i = 0; i < this.subs.length; i++) { this.subs[i].destroy(); } this.subs = null; } this.io.destroy(this); }; /** * Disconnects the socket manually. * * @return {Socket} self * @api public */ Socket.prototype.close = Socket.prototype.disconnect = function () { if (this.connected) { this.packet({ type: parser.DISCONNECT }); } // remove socket from pool this.destroy(); if (this.connected) { // fire events this.onclose('io client disconnect'); } return this; }; /** * Sets the compress flag. * * @param {Boolean} if `true`, compresses the sending data * @return {Socket} self * @api public */ Socket.prototype.compress = function (compress) { this.flags.compress = compress; return this; }; /** * Sets the binary flag * * @param {Boolean} whether the emitted data contains binary * @return {Socket} self * @api public */ Socket.prototype.binary = function (binary) { this.flags.binary = binary; return this; }; // WEBPACK FOOTER // // ./lib/socket.js",
"module.exports = toArray function toArray(list, index) { var array = [] index = index || 0 for (var i = index || 0; i < list.length; i++) { array[i - index] = list[i] } return array } ////////////////// // WEBPACK FOOTER // ./~/to-array/index.js // module id = 35 // module chunks = 0",
" /** * Module exports. */ module.exports = on; /** * Helper for subscriptions. * * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter` * @param {String} event name * @param {Function} callback * @api public */ function on (obj, ev, fn) { obj.on(ev, fn); return { destroy: function () { obj.removeListener(ev, fn); } }; } // WEBPACK FOOTER // // ./lib/on.js",
"/** * Slice reference. */ var slice = [].slice; /** * Bind `obj` to `fn`. * * @param {Object} obj * @param {Function|String} fn or string * @return {Function} * @api public */ module.exports = function(obj, fn){ if ('string' == typeof fn) fn = obj[fn]; if ('function' != typeof fn) throw new Error('bind() requires a function'); var args = slice.call(arguments, 2); return function(){ return fn.apply(obj, args.concat(slice.call(arguments))); } }; ////////////////// // WEBPACK FOOTER // ./~/component-bind/index.js // module id = 37 // module chunks = 0",
" /** * Expose `Backoff`. */ module.exports = Backoff; /** * Initialize backoff timer with `opts`. * * - `min` initial timeout in milliseconds [100] * - `max` max timeout [10000] * - `jitter` [0] * - `factor` [2] * * @param {Object} opts * @api public */ function Backoff(opts) { opts = opts || {}; this.ms = opts.min || 100; this.max = opts.max || 10000; this.factor = opts.factor || 2; this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0; this.attempts = 0; } /** * Return the backoff duration. * * @return {Number} * @api public */ Backoff.prototype.duration = function(){ var ms = this.ms * Math.pow(this.factor, this.attempts++); if (this.jitter) { var rand = Math.random(); var deviation = Math.floor(rand * this.jitter * ms); ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation; } return Math.min(ms, this.max) | 0; }; /** * Reset the number of attempts. * * @api public */ Backoff.prototype.reset = function(){ this.attempts = 0; }; /** * Set the minimum duration * * @api public */ Backoff.prototype.setMin = function(min){ this.ms = min; }; /** * Set the maximum duration * * @api public */ Backoff.prototype.setMax = function(max){ this.max = max; }; /** * Set the jitter * * @api public */ Backoff.prototype.setJitter = function(jitter){ this.jitter = jitter; }; ////////////////// // WEBPACK FOOTER // ./~/backo2/index.js // module id = 38 // module chunks = 0"
],
sourceRoot: ""
}